<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>leaf++ blog</title>
  
  <link href="/blog/atom.xml" rel="self"/>
  
  <link href="https://leaf930814.github.io/"/>
  <updated>2019-10-16T04:11:52.464Z</updated>
  <id>https://leaf930814.github.io/</id>
  
  <author>
    <name>leaf</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>《白帽子讲WEB安全》读书笔记</title>
    <link href="https://leaf930814.github.io/notes/2019/09/20/%E3%80%8A%E7%99%BD%E5%B8%BD%E5%AD%90%E8%AE%B2WEB%E5%AE%89%E5%85%A8%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    <id>https://leaf930814.github.io/notes/2019/09/20/《白帽子讲WEB安全》读书笔记/</id>
    <published>2019-09-20T14:25:00.000Z</published>
    <updated>2019-10-16T04:11:52.464Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://raw.githubusercontent.com/leaf930814/blog-misc/master/img/cyber_security_2.png" alt="image"></p><h4 id="第1章-我的安全世界观"><a href="#第1章-我的安全世界观" class="headerlink" title="第1章 我的安全世界观"></a>第1章 我的安全世界观</h4><p>安全评估的过程，可以简单分为 4 个阶段：资产等级划分、威胁分析、风险分析、确认解决方案。</p><p>Secure By Default 原则、纵深防御原则、数据与代码分离原则、不可预测性原则</p><h4 id="第2章-浏览器安全"><a href="#第2章-浏览器安全" class="headerlink" title="第2章 浏览器安全"></a>第2章 浏览器安全</h4><p>同源策略是浏览器安全基础</p><p>浏览器沙箱：让不可信任代码运行在一定环境中，限制访问隔离区之外的资源</p><p>恶意网址拦截</p><h4 id="第3章-跨站脚本攻击（XSS）"><a href="#第3章-跨站脚本攻击（XSS）" class="headerlink" title="第3章 跨站脚本攻击（XSS）"></a>第3章 跨站脚本攻击（XSS）</h4><h5 id="Cross-Site-Script简介"><a href="#Cross-Site-Script简介" class="headerlink" title="Cross Site Script简介"></a>Cross Site Script简介</h5><ul><li>概念：黑客通过“HTML注入”篡改网页，插入恶意脚本，从而在用户浏览网页时，控制用户浏览器。</li><li>根据效果分类：<ul><li>反射型XSS：简单地把用户输入的数据反射给浏览器。</li><li>存储型XSS：会把用户输入的数据存储在服务器端，这种XSS具有稳定性。<h5 id="XSS攻击进阶"><a href="#XSS攻击进阶" class="headerlink" title="XSS攻击进阶"></a>XSS攻击进阶</h5></li></ul></li><li>构造技巧：<ul><li>利用字符编码</li><li>绕过长度限制</li><li>使用<base>标签</li><li>Window.name:可以实现跨域，跨页面传递数据</li></ul></li><li>防御<ul><li>HttpOnly,解决cookie劫持</li><li>浏览器filter</li><li>输出检查：编码，转义</li></ul></li></ul><h4 id="第4章-跨站点请求伪造（CSRF）"><a href="#第4章-跨站点请求伪造（CSRF）" class="headerlink" title="第4章 跨站点请求伪造（CSRF）"></a>第4章 跨站点请求伪造（CSRF）</h4><ul><li>通过伪装来自受信任用户的请求来利用受信任的网站<h5 id="CSRF进阶"><a href="#CSRF进阶" class="headerlink" title="CSRF进阶"></a>CSRF进阶</h5></li><li>浏览器cookie：一种是Session Cookie，没有指定expire，浏览器关闭，cookie就失效，另一种是Third-party-Cookie，又称为本地cookie，只有expire时间到了后才会失效。</li><li>如果当前浏览器会拦截本地cookie，那就需要攻击者构造攻击环境，诱使用户在浏览器中先访问目标站点，使session cookie生效，再进行CSRF攻击</li><li>如果网站返回给浏览器的HTTP头中携带有P3P头，将允许浏览器发送第三方Cookie，即使在ie下也不会拦截。但是由于cookie是以域和path为单位的，p3p头的设置会影响整个域的所有页面。</li><li>不仅是get，CSRF也可以发起post请求</li><li>防御：<ul><li>验证码：最简洁有效的防御手段，但是用户体验差。</li><li>Referer Check：也可以被用于检查请求是否来自合法的源，但是服务器端并不是任何时候都可以获取到Referer，所以不能作为主要防御手段。</li><li>Anti Csrf token：使用token是业界一致的做法，token的生成需要具有随机性和保密性</li></ul></li></ul><h4 id="第5章-点击劫持（ClickJacking）"><a href="#第5章-点击劫持（ClickJacking）" class="headerlink" title="第5章 点击劫持（ClickJacking）"></a>第5章 点击劫持（ClickJacking）</h4><ul><li><p>拖拽劫持 数据窃取 触屏劫持</p></li><li><p>防御：JavaScript禁止iframe嵌套 HTTP头X-Frame-Options</p></li><li><p>iframe 可设置 sandbox 参数</p></li></ul><h4 id="第6章-HTML5-安全"><a href="#第6章-HTML5-安全" class="headerlink" title="第6章 HTML5 安全"></a>第6章 HTML5 安全</h4><ul><li>HTML5新标签的XSS：可能带来新的XSS攻击。</li></ul><h4 id="注入攻击"><a href="#注入攻击" class="headerlink" title="注入攻击"></a>注入攻击</h4><ul><li>两个关键条件：第一个是用户能够控制输入，第二个是原本程序要执行的代码，拼接了用户输入的数据。<h5 id="SQL注入"><a href="#SQL注入" class="headerlink" title="SQL注入"></a>SQL注入</h5></li><li>发现漏洞方式<ul><li>攻击者通过web服务器的错误回显构造sql注入语句</li><li>没有错误回显一样可以实现注入，就是所谓的盲注，是通过简单的条件判断对比返回结果来发现漏洞。</li></ul></li><li>防御<ul><li>建立数据库账号时要遵循“最小权限”原则，每个应用分配不同的账号，且账号不应该具有创建自定义函数和操作本地文件的权限</li><li>使用预编译语句：这是防御sql注入的最佳方式，攻击者无法改变sql语句的结构</li><li>使用存储过程：但是存储过程也存在注入风险，所以应避免在存储过程中使用动态语句</li><li>检查数据类型：比如限制输入为Intger类型，比如限制输入为日期格式等<h5 id="其他注入攻击"><a href="#其他注入攻击" class="headerlink" title="其他注入攻击"></a>其他注入攻击</h5></li></ul></li><li>XML注入</li><li>代码注入</li><li>CRLF注入</li></ul>]]></content>
    
    <summary type="html">
    
      互联网本来是安全的，因为有了研究安全的人所以才会不安全。
    
    </summary>
    
      <category term="Web开发" scheme="https://leaf930814.github.io/cates/Web%E5%BC%80%E5%8F%91/"/>
    
    
      <category term="Web开发" scheme="https://leaf930814.github.io/tags/Web%E5%BC%80%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>椭圆曲线加密原理与应用</title>
    <link href="https://leaf930814.github.io/notes/2019/08/12/%E6%A4%AD%E5%9C%86%E6%9B%B2%E7%BA%BF%E5%8A%A0%E5%AF%86%E5%8E%9F%E7%90%86%E4%B8%8E%E5%BA%94%E7%94%A8/"/>
    <id>https://leaf930814.github.io/notes/2019/08/12/椭圆曲线加密原理与应用/</id>
    <published>2019-08-12T12:00:00.000Z</published>
    <updated>2019-10-16T04:11:52.464Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一-概述"><a href="#一-概述" class="headerlink" title="一. 概述"></a>一. 概述</h2><p>由于RSA、AES等国际算法面临高强度算法禁售和被部署后门风险，我国基于ECC椭圆曲线，自研SM2/SM3/SM4/SM9一套安全算法。根据国家整体战略，金融及重要领域要逐步实现国密算法替换，另根据人民银行总体规划，在2022年金融行业要全面应用国密算法。</p><p>在FireFly移动金融开发平台中，完善的提供了支持国密算法的加解密算法包。为了更好的使用和推广国密算法，下面具体分析ECC椭圆曲线的加密原理。</p><h2 id="二-椭圆曲线算法原理"><a href="#二-椭圆曲线算法原理" class="headerlink" title="二. 椭圆曲线算法原理"></a>二. 椭圆曲线算法原理</h2><p>椭圆曲线(Elliptic Curve Cryptography)加密算法是一种公钥加密技术，以椭圆曲线理论为基础。利用有限域上椭圆曲线的点构成的Abel群离散对数难解性，实现加密、解密和数字签名。将椭圆曲线中的加法运算与离散对数中的模乘运算相对应，就可以建立基于椭圆曲线的对应密码体制。</p><h2 id="三-椭圆曲线算法优势"><a href="#三-椭圆曲线算法优势" class="headerlink" title="三. 椭圆曲线算法优势"></a>三. 椭圆曲线算法优势</h2><p><img src="https://blockfe.github.io/misc/xlogic/post_ecc_01.jpg" alt></p><h3 id="1-更适合于移动互联网"><a href="#1-更适合于移动互联网" class="headerlink" title="1. 更适合于移动互联网"></a>1. 更适合于移动互联网</h3><p>在同等加密安全强度下，ECC密钥长度为163bit，而RSA密钥长度为1024bit。ECC加密算法的密钥长度很短，意味着占用更少的存储空间，更低的CPU开销和占用更少的带宽。随着越来越多的用户使用移动设备来完成各种网上活动，ECC加密算法为移动互联网安全提供更好的客户体验。</p><h3 id="2-更好的安全性"><a href="#2-更好的安全性" class="headerlink" title="2. 更好的安全性"></a>2. 更好的安全性</h3><p>ECC加密算法提供更强的保护，比目前的其他加密算法能更好的防止攻击，使你的网站和基础设施比用传统的加密方法更安全，为移动互联网安全提供更好的保障。</p><h3 id="3-更好的性能"><a href="#3-更好的性能" class="headerlink" title="3. 更好的性能"></a>3. 更好的性能</h3><p>ECC加密算法需要较短的密钥长度来提供更好的安全。</p><h2 id="四-椭圆曲线理论基础"><a href="#四-椭圆曲线理论基础" class="headerlink" title="四.椭圆曲线理论基础"></a>四.椭圆曲线理论基础</h2><h3 id="1-定义"><a href="#1-定义" class="headerlink" title="1. 定义"></a>1. 定义</h3><p>一条椭圆曲线是在射影平面上满足方程</p><p>Y<sup>2</sup>Z + a<sub>1</sub>XYZ + a<sub>3</sub>Yz<sup>2</sup> = X<sup>3</sup>+ a<sub>2</sub>X<sup>2</sup>Z + a<sub>4</sub>XZ<sup>2</sup> + a<sub>5</sub>Z<sup>3</sup></p><p>所有点的集合，且曲线上的每个点都是非奇异（或光滑）的。</p><ul><li><p>该方程是Weierstrass方程，是一个齐次方程。</p></li><li><p>椭圆曲线的形状，并不是椭圆的。只是因为椭圆曲线的描述方程，类似于计算一个椭圆周长的方程，故得名。下面是椭圆曲线的形状：</p></li></ul><p><img src="https://blockfe.github.io/misc/xlogic/post_ecc_02.jpg" alt></p><ul><li>由椭圆曲线的定义可以知道，椭圆曲线是光滑的，所以椭圆曲线上的平常点都有切线。</li></ul><h3 id="2-椭圆曲线上的加法"><a href="#2-椭圆曲线上的加法" class="headerlink" title="2. 椭圆曲线上的加法"></a>2. 椭圆曲线上的加法</h3><p>① 运算法则</p><p>任意取椭圆曲线上两点P、Q （若P、Q两点重合，则做P点的切线）做直线交于椭圆曲线的另一点R’，过R’做y轴的平行线交于R。我们规定P+Q=R。（如图）</p><p><img src="https://blockfe.github.io/misc/xlogic/post_ecc_03.jpg" alt><img src="https://blockfe.github.io/misc/xlogic/post_ecc_04.jpg" alt></p><p>② 运算法则详解</p><ul><li><p>这里的+是从普通加法中抽象出来的加法，他具备普通加法的一些性质，但具体的运算法则显然与普通加法不同。</p></li><li><p>k个相同的点P相加，我们记作kP。如下图：P+P+P = 2P+P = 3P，3P即为P点的3倍点。</p></li></ul><p><img src="https://blockfe.github.io/misc/xlogic/post_ecc_05.jpg" alt></p><h3 id="3-有限域上的椭圆曲线"><a href="#3-有限域上的椭圆曲线" class="headerlink" title="3. 有限域上的椭圆曲线"></a>3. 有限域上的椭圆曲线</h3><p>① 有限域</p><p>前面讲到的椭圆曲线是定义在实数域上的，实数是连续的，导致了椭圆曲线的连续，但是并不适合用于加密。所以，必须把椭圆曲线变成离散的点，需要把椭圆曲线定义在有限域上（顾名思义，有限域是一种只有由有限个元素组成的域）。 </p><p>下面，给出一个有限域Fp，这个域只有有限个元素。</p><p>Fp中只有p（p为素数）个元素0,1,2 …… p-2,p-1；</p><p>Fp 的加法（a+b）法则是a+b≡c (mod p)；即(a+b)÷p的余数和c÷p的余数相同。</p><p>Fp 的乘法(a×b)法则是  a×b≡c (mod p)；</p><p>Fp 的除法(a÷b)法则是  a/b≡c (mod p)；即a×b-1≡c  (mod p)；（b-1也是一个0到p-1之间的整数，但满足b×b-1≡1 (mod p)；</p><p>Fp 的单位元是1，零元是0。</p><p>② 可加密椭圆曲线</p><p>同时，并不是所有的椭圆曲线都适合加密。y<sup>2 </sup>= x<sup>3 </sup>+ ax + b是一类可以用来加密的椭圆曲线，也是最为简单的一类。下面就把 y<sup>2 </sup>= x<sup>3 </sup>+ ax + b这条曲线定义在Fp上：</p><p>选择两个满足下列条件的小于p(p为素数)的非负整数a、b </p><p> 4a<sup>3</sup> + 27b<sup>2</sup> ≠ 0 (mod p) </p><p>则满足下列方程的所有点(x,y)，再加上无穷远点O∞ ，构成一条椭圆曲线。</p><p> y<sup>2</sup> = x<sup>3 </sup>+ ax + b(mod p) </p><p>其中x,y属于0到p-1间的整数，并将这条椭圆曲线记为Ep(a,b)。</p><p>示例：查看 y<sup>2</sup> = x<sup>3</sup> + x + 1 (mod 23)的图像</p><p><img src="https://blockfe.github.io/misc/xlogic/post_ecc_06.jpg" alt></p><p>这样椭圆曲线，就成了一个一个离散的点，椭圆曲线在不同的数域中会呈现出不同的样子，但其本质仍是一条椭圆曲线。</p><p>③ 计算椭圆曲线上点的坐标</p><p>Fp上的椭圆曲线同样有加法，根据加法法则，可以计算出椭圆曲线上点的坐标。</p><p>已知点P(x<sub>1</sub>, y<sub>1</sub>), Q(x<sub>2</sub>,y<sub>2</sub>)，计算点R(x<sub>3</sub>, y<sub>3</sub>)：</p><p>  X<sub>3</sub> ≡ k<sup>2</sup> – x<sub>1</sub> – y<sub>1</sub> (mod p) </p><p>  Y<sub>3</sub> ≡ k(x<sub>1</sub>–x<sub>3</sub>) –y<sub>1</sub> (mod p) </p><p>若P≠Q，PQR三点共线，其斜率 k=(y<sub>2</sub>–y<sub>1</sub>) / (x<sub>2</sub> –x<sub>1</sub>) 。</p><p>其中若P=Q，PR为过P点的椭圆切线，其斜率 k=(3x<sub>1</sub><sup>2</sup>+ a) / 2y<sub>1</sub></p><p>④ 椭圆曲线上的点的阶</p><p>如果椭圆曲线上一点P，存在最小的正整数n，使得数乘nP=O∞，则将n称为P的阶，若n不存在，我们说P是无限阶的。事实上，在有限域上定义的椭圆曲线上所有的点的阶n都是存在的。</p><h2 id="五-椭圆曲线加解密原理"><a href="#五-椭圆曲线加解密原理" class="headerlink" title="五. 椭圆曲线加解密原理"></a>五. 椭圆曲线加解密原理</h2><h3 id="1-加解密依据"><a href="#1-加解密依据" class="headerlink" title="1. 加解密依据"></a>1. 加解密依据</h3><p>公开密钥算法总是要基于一个数学上的难题。比如RSA依据的是：给定两个素数p、q 很容易相乘得到n，而对n进行因式分解却相对困难。那椭圆曲线上有什么难题呢？</p><p>考虑如下等式：</p><p>K=kG  [其中K,G为Ep(a,b)上的点，k为小于n（n是点G的阶）的整数] </p><p>给定k和G，根据加法法则，计算K很容易；但给定K和G，求k就相对困难了。这就是椭圆曲线加密算法采用的难题。</p><p>我们把点G称为基点（base point），k（k&lt;n，n为基点G的阶）称为私有密钥（privte key），K称为公开密钥（public key)。</p><p>k = 2，K为G的2倍点;</p><p>k = 3，K为G的3倍点;</p><p>k = 4，K为G的4倍点;</p><p>…</p><p>如果给定椭圆曲线上K为G的一个倍点，如何计算K为G的多少倍？直观上理解，正向计算一个倍点是容易的，反向计算一个点K是G的几倍点则困难的多。因此在椭圆曲线算法中，将倍数k做为私钥，将K做为公钥。</p><h3 id="2-加解密过程"><a href="#2-加解密过程" class="headerlink" title="2. 加解密过程"></a>2. 加解密过程</h3><p>现在我们描述一个利用椭圆曲线进行加密通信的过程：</p><ol><li><p>用户A选定一条椭圆曲线Ep(a,b)，并取椭圆曲线上一点，作为基点G。</p></li><li><p>用户A选择一个私有密钥k，并生成公开密钥K=kG。</p></li><li><p>用户A将Ep(a,b)和点K，G传给用户B。</p></li><li><p>用户B接到信息后，将待传输的明文编码到Ep(a,b)上一点M（编码方法很多，这里不作讨论），并产生一个随机整数r（r&lt;n）。</p></li><li><p>用户B计算点C<sub>1</sub>=M+rK；C<sub>2</sub>=rG。</p></li><li><p>用户B将C<sub>1</sub>、C<sub>2</sub>传给用户A。</p></li><li><p>用户A接到信息后，计算C<sub>1</sub>-kC<sub>2</sub>，结果就是点M。因为</p></li></ol><p>C<sub>1</sub>-kC<sub>2</sub>=M+rK-k(rG)=M+rK-r(kG)=M</p><p>再对点M进行解码就可以得到明文。</p><p>在这个加密通信中，如果有一个偷窥者H ，他只能看到Ep(a,b)、K、G、C<sub>1</sub>、C<sub>2</sub>而通过K、G 求k 或通过C<sub>2</sub>、G求r 都是相对困难的。因此，H无法得到A、B间传送的明文信息。</p><h3 id="3-加解密参数"><a href="#3-加解密参数" class="headerlink" title="3. 加解密参数"></a>3. 加解密参数</h3><p>密码学中，描述一条Fp上的椭圆曲线，常用到六个参数：</p><pre><code>T=(p,a,b,G,n,h)。</code></pre><p>   p 、a 、b 用来确定一条椭圆曲线，</p><p>   G为基点，</p><p>   n为点G的阶，</p><p>   h 是椭圆曲线上所有点的个数m与n相除的整数部分。</p><p>   这几个参数取值的选择，直接影响了加密的安全性。参数值一般要求满足以下几个条件：</p><ol><li><p>p 当然越大越安全，但越大，计算速度会变慢，200位左右可以满足一般安全要求；</p></li><li><p>p≠n×h；</p></li><li><p>pt≠1 (mod n)，1≤t&lt;20；</p></li><li><p>4a<sup>3</sup> + 27b<sup>2</sup> ≠ 0 (mod p)；</p></li><li><p>n 为素数；</p></li><li><p>h≤4。</p></li></ol><h2 id="六-椭圆曲线数字签名原理-ECDSA"><a href="#六-椭圆曲线数字签名原理-ECDSA" class="headerlink" title="六.椭圆曲线数字签名原理(ECDSA)"></a>六.椭圆曲线数字签名原理(ECDSA)</h2><h3 id="1-概述"><a href="#1-概述" class="headerlink" title="1. 概述"></a>1. 概述</h3><p>椭圆曲线数字签名算法（ECDSA）是使用椭圆曲线密码（ECC）对数字签名算法（DSA）的模拟。</p><p>ECDSA是ECC与DSA的结合，整个签名过程与DSA类似，所不一样的是签名中采取的算法为ECC，最后签名出来的值也是分为r,s。</p><h3 id="2-签名过程"><a href="#2-签名过程" class="headerlink" title="2. 签名过程"></a>2. 签名过程</h3><ol><li><p>选择一条椭圆曲线Ep(a,b)，和基点G；</p></li><li><p>选择私有密钥k（k&lt;n，n为G的阶），利用基点G计算公开密钥K=kG；</p></li><li><p>产生一个随机整数r（r&lt;n），计算点R=rG；</p></li><li><p>将原数据和点R的坐标值x,y作为参数，计算SHA1做为hash，即Hash=SHA1(原数据,x,y)；</p></li><li><p>计算s≡r - Hash * k (mod n)；</p></li><li><p>r和s做为签名值，如果r和s其中一个为0，重新从第3步开始执行。</p></li></ol><h3 id="3-验签过程"><a href="#3-验签过程" class="headerlink" title="3. 验签过程"></a>3. 验签过程</h3><p>接受方在收到消息(m)和签名值(r,s)后，进行以下运算：</p><ol><li><p>计算：sG+H(m)P=(x1,y1), r1≡x1 mod p。</p></li><li><p>验证等式：r1 ≡r mod p。</p></li><li><p>如果等式成立，接受签名，否则签名无效。</p></li></ol><h2 id="七-椭圆曲线算法应用"><a href="#七-椭圆曲线算法应用" class="headerlink" title="七.椭圆曲线算法应用"></a>七.椭圆曲线算法应用</h2><p>椭圆加密算法的应用范围很广，如 TLS、openPGP以及SSH都在使用，在比特币以及其他加密数字货币中也得到广泛使用。另外我国重点推广的国密SM2算法也正是基于椭圆曲线算法。下面以SM2和TLS为例进行说明：</p><h3 id="1-SM2"><a href="#1-SM2" class="headerlink" title="1. SM2"></a>1. SM2</h3><p>① 概述</p><p>SM2算法和RSA算法都是公钥密码算法，随着密码技术和计算技术的发展，目前常用的1024位RSA算法面临严重的安全威胁，我们国家密码管理部门经过研究，决定采用SM2椭圆曲线算法替换RSA算法。SM2算法在安全性、性能上都具有优势，参见表1算法攻破时间，表2算法性能。</p><table><thead><tr><th>RSA密钥强度</th><th>椭圆曲线密钥强度</th><th>是否攻破</th></tr></thead><tbody><tr><td>512</td><td>106</td><td>已被攻破</td></tr><tr><td>768</td><td>132</td><td>已被攻破</td></tr><tr><td>1024</td><td>160</td><td>-</td></tr><tr><td>2048</td><td>210</td><td>-</td></tr></tbody></table><p>表1 算法攻破时间</p><table><thead><tr><th>算法</th><th>签名速度(次/秒)</th><th>验签速度(次/秒)</th></tr></thead><tbody><tr><td>1024位RSA</td><td>2792</td><td>51224</td></tr><tr><td>2048位RSA</td><td>455</td><td>15122</td></tr><tr><td>256位SM2</td><td>4095</td><td>871</td></tr></tbody></table><p>表2 算法性能</p><p>② SM2和椭圆曲线算法之间的关系</p><p>SM2算法采用的椭圆曲线方程为：y<sup>2</sup>= x<sup>3</sup>+ ax + b,在SM2算法标准中，通过指定a、b系数，确定了唯一的标准曲线。同时，为了将曲线映射为加密算法，SM2标准中还确定了其它参数，供算法程序使用。</p><p>③ SM2加解密过程</p><p>下面是SM2加解密流程中使用到的符号缩略语：</p><p>A, B     使用公钥密码系统的两个用户。</p><p>dB       用户B 的私钥。</p><p>E(Fq)    Fq 上椭圆曲线E 的所有有理点(包括无穷远点O)组成的集合。</p><p>Fq        包含q 个元素的有限域。</p><p>G          椭圆曲线的一个基点，其阶为素数。</p><p>Hash()  密码杂凑算法。</p><p>Hv( )     消息摘要长度为v 比特的密码杂凑算法。</p><p>KDF( )   密钥派生函数。</p><p>h           余因子，h=#E(Fq)/n，其中n 是基点G 的阶。</p><p>M          待加密的消息。</p><p>M’         解密得到的消息。</p><p>n           基点G 的阶(n 是#E(Fq)的素因子)。</p><p>O          椭圆曲线上的一个特殊点，称为无穷远点或零点，是椭圆曲线加法群的单位元。</p><p>PB        用户B 的公钥。</p><p>q          有限域Fq 中元素的数目。</p><p>a, b       Fq 中的元素，它们定义Fq 上的一条椭圆曲线E。</p><p>x||y        x 与y 的拼接，x、y 是比特串或字节串。</p><p>[k]P       椭圆曲线上点P 的k 倍点。</p><p>E(Fq)    E(Fq)上点的数目，称为椭圆曲线E(Fq)的阶。</p><p>M⊕t     xor运算</p><p>a. 加密算法流程</p><p>SM2加密使用公钥加密，公钥由一个曲线坐标点组成，在X.509证书中的公钥表示为04标记开始的2个32byte的BigInteger，即曲线点P（x,y）。SM2公钥加密算法比RSA相对复杂，加密结果由3个部分组成，SM2加密过程中使用了随机数，因此同样的明文数据每一次加密结果都不一样。</p><p>设需要发送的消息为比特串M，klen 为M 的比特长度。</p><p>为了对明文M 进行加密，作为加密者的用户A 应实现以下运算步骤：</p><p>A1：用随机数发生器产生随机数k∈[1, n-1]；</p><p>A2：计算椭圆曲线点C1 = [k]G=(x1, y1)，按SM2 椭圆曲线公钥密码算法第1 部分3.2.9 和3.2.5 给</p><p>出的方法，将C1 的数据类型转换为比特串；</p><p>A3：计算椭圆曲线点S= [h]PB，若S 是无穷远点，则报错并退出；</p><p>A4：计算椭圆曲线点[k]PB=(x2, y2)，按SM2 椭圆曲线公钥密码算法第1 部分3.2.6 和3.2.5 给出的</p><p>方法，将坐标x2、y2 的数据类型转换为比特串；</p><p>A5：计算t = KDF(x2||y2，klen)，若t 为全0 比特串，则返回A1；</p><p>A6：计算C2=M⊕t；</p><p>A7：计算C3= Hash (x2||M|| y2)；</p><p>A8：输出密文C=C1||C3||C2。</p><p><img src="https://blockfe.github.io/misc/xlogic/post_ecc_07.jpg" alt></p><p>根据国密推荐的SM2椭圆曲线公钥密码算法，首先产生随机数计算出曲线点C1，2个32byte的BigInteger大数，即为SM2加密结果的第1部分。第2部分则是真正的密文，是对明文的加密结果，长度和明文一样。第3部分是杂凑值，用来效验数据。按国密推荐的256位椭圆曲线，明文加密结果比原长度会大96byte。</p><p>b. 解密算法流程</p><p>SM2解密算法是加密逆运算。首先需要从密文中取出加密结果的3部分值，然后通过私钥计算出M’明文值，最后效验数据</p><p>设klen 为密文中C2 的比特长度。</p><p>为了对密文C=C1||C3||C2 进行解密，作为解密者的用户B 应实现以下运算步骤：</p><p>B1：从C 中取出比特串C1，按SM2 椭圆曲线公钥密码算法第1 部分3.2.4 和3.2.10 给出的方法，</p><p>将C1 的数据类型转换为椭圆曲线上的点，验证C1 是否满足椭圆曲线方程，若不满足则报错</p><p>并退出；</p><p>B2：计算椭圆曲线点S= [h]C1，若S 是无穷远点，则报错并退出；</p><p>B3：计算[dB]C1= (x2, y2)，按SM2 椭圆曲线公钥密码算法第1 部分3.2.6 和3.2.5 给出的方法，将</p><p>坐标x2、y2 的数据类型转换为比特串；</p><p>B4：计算t = KDF(x2||y2，klen)，若t 为全0 比特串，则报错并退出；</p><p>B5：从C 中取出比特串C2，计算M’=C2⊕t；</p><p>B6：计算u = Hash (x2||M’|| y2)，从C 中取出比特串C3，若u≠C3，则报错并退出；</p><p>B7：输出明文M’。</p><p><img src="https://blockfe.github.io/misc/xlogic/post_ecc_08.jpg" alt></p><p>SM2解密同样也可以使用软算法实现。但因为涉及到私钥运算，为保护私钥安全，建议在硬件设备中运行，例如UKey等存储介质这样可以更好的保护密钥安全。拿文件加密来说，首先拿UKey里面的加密证书加密，这部分可在应用系统内完成。解密的话则需要加密证书对应UKey才能做解密，由应用系统调用UKey解密接口，在物理硬件内完成数据解密，同时可以受设备PIN码保护。</p><p>④ SM2算法的速度和结果长度</p><p>简单讲，SM2签名速度快，验签速度慢，这点和RSA算法的特性正好相反。参见上表2。另外，加解密速度和验签速度相当。</p><p>SM2支持近128G字节数据长度，加密结果增加96个字节。</p><p>SM2签名算法对原始数据量长度无限制，签名结果为64字节。</p><h3 id="2-TLS"><a href="#2-TLS" class="headerlink" title="2. TLS"></a>2. TLS</h3><p>① 概述</p><p>HTTPS 通过TLS 层和证书机制提供了内容加密、身份认证和数据完整性三大功能，可以有效防止数据被监听或篡改，还能抵御MITM（中间人）攻击。TLS 在实施加密过程中，需要用到非对称密钥交换和对称内容加密两大算法。对称内容加密强度非常高，加解密速度也很快，只是无法安全地生成和保管密钥。在TLS 协议中，应用数据都是经过对称加密后传输的，传输中所使用的对称密钥，则是在握手阶段通过非对称密钥交换而来。</p><p>② TLS中密钥交换算法</p><p>目前最常用的密钥交换算法有RSA 和ECDHE：RSA 历史悠久，支持度好，但不支持PFS（Perfect Forward Secrecy）；而ECDHE 是使用了ECC（椭圆曲线）的DH（Diffie-Hellman）算法，计算速度快，支持PFS。</p><p>③ 基于ECC的密钥交换算法</p><p>下面是五种常见的基于ECC的TLS 密钥交换算法，它们分别模仿DH_DSS，DHE_DSS，DH_RSA，DHE_RSA和DH_anon。</p><p><img src="https://blockfe.github.io/misc/xlogic/post_ecc_09.jpg" alt></p><p>以ECDHE_ECDSA为例：</p><p>证书包含ECDSA-capable 公钥，使用ECDHE 算法协商预备主密钥; 证书必须允许密钥用于使用将在Server 密钥交换消息中使用的散列算法进行签名;公钥必须使用一个能够被Client 支持的曲线和点格式，Client 通过Client Hello 消息中的ec_point_formats 扩展指定支持的命名曲线，正如 [TLSECC] 中描述的那样。这是TLS 1.2 中最安全，性能最高的密码套件。</p><p>④ ECDHE密钥交换的完整握手流程</p><p>A: 客户端向服务器发送Client Hello,告知服务器，客户端支持的协议版本、加密套件等信息。</p><p>B:  a. 服务端收到响应，选择双方都支持的协议、套件，向客户端发送Server Hello，同时服务器也将自己的证书发送到客户端(Certificate)。</p><p>   b. 服务器利用私钥将客户端随机数、服务器随机数、服务器DH参数签名，生成服务器签名。</p><p>C: 服务端向客户端发送服务器DH参数以及服务器签名(Server Key Exchange)。</p><p>D: 客户端向服务端发送客户端DH参数(Client Key Exchange)。</p><p>之后，客户端利用公钥验证服务器签名，客户端与服务器各自利用服务端DH参数、客户端DH参数生成预主密钥，再通过预主密钥、客户端随机数、服务端随机数生成主密钥(会话密钥)。最后握手完成，所有的消息都通过主密钥加密。如图：</p><p><img src="https://blockfe.github.io/misc/xlogic/post_ecc_10.jpg" alt></p><h2 id="八-结语"><a href="#八-结语" class="headerlink" title="八. 结语"></a>八. 结语</h2><p>椭圆曲线ECC算法基于椭圆曲线理论，可以用较少的计算能力提供更高的安全强度，有效地解决了“提高安全强度必须增加密钥长度”的工程实现问题，且已经得到广泛的支持和使用，读者在选择加密算法时，ECC算法不失为一个优秀的选择。</p><h2 id="九-参考资料"><a href="#九-参考资料" class="headerlink" title="九. 参考资料"></a>九. 参考资料</h2><p>ECC加密算法入门介绍</p><p><a href="https://www.pediy.com/kssd/pediy06/pediy6014.htm" target="_blank" rel="noopener">https://www.pediy.com/kssd/pediy06/pediy6014.htm</a></p><p>Elliptic Curve Cryptography: a gentle introduction</p><p><a href="https://andrea.corbellini.name/2015/05/17/elliptic-curve-cryptography-a-gentle-introduction/" target="_blank" rel="noopener">https://andrea.corbellini.name/2015/05/17/elliptic-curve-cryptography-a-gentle-introduction/</a></p><p>国家密码管理局</p><p><a href="http://www.oscca.gov.cn/" target="_blank" rel="noopener">http://www.oscca.gov.cn/</a></p><p>国家商用密码（一）SM2椭圆曲线公钥密码算法</p><p><a href="http://www.firstsolver.com/wordpress/?p=1938" target="_blank" rel="noopener">http://www.firstsolver.com/wordpress/?p=1938</a></p><p>TLS_ECC</p><p><a href="https://tools.ietf.org/html/rfc4492" target="_blank" rel="noopener">https://tools.ietf.org/html/rfc4492</a></p>]]></content>
    
    <summary type="html">
    
      由于RSA、AES等国际算法面临高强度算法禁售和被部署后门风险，我国基于ECC椭圆曲线，自研SM2/SM3/SM4/SM9一套安全算法。
    
    </summary>
    
      <category term="Web开发" scheme="https://leaf930814.github.io/cates/Web%E5%BC%80%E5%8F%91/"/>
    
    
      <category term="加密算法" scheme="https://leaf930814.github.io/tags/%E5%8A%A0%E5%AF%86%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>Sentry - 及时发现Bug，提高Debug效率</title>
    <link href="https://leaf930814.github.io/notes/2019/05/16/to-improve-debug-efficiency/"/>
    <id>https://leaf930814.github.io/notes/2019/05/16/to-improve-debug-efficiency/</id>
    <published>2019-05-16T04:43:35.000Z</published>
    <updated>2019-10-16T04:11:52.464Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Sentry简介"><a href="#Sentry简介" class="headerlink" title="Sentry简介"></a>Sentry简介</h2><p>Sentry是一款异常监控开源工具，名字翻译过来就是“哨兵”，在Github上面的简介是：“跨平台应用监控，关注错误报告”。支持各种语言，例如 python、oc、java、node、javascript 等。也可以应用到各种不同的框架上面，如前端框架中的vue 、angular 、react 等最流行的前端框架。Sentry分为社区开源版和在线Saas版，这里我们已经在自己服务器部署了一套服务。</p><p>官网： <a href="https://sentry.io/" target="_blank" rel="noopener">https://sentry.io</a></p><p>文档： <a href="https://docs.sentry.io/clients/javascript/install/" target="_blank" rel="noopener">https://docs.sentry.io/clients/javascript/install/</a></p><p>Github仓库： <a href="https://github.com/getsentry/sentry" target="_blank" rel="noopener">https://github.com/getsentry/sentry</a></p><p>社区除了github issue外还可以关注 <a href="https://forum.sentry.io/" target="_blank" rel="noopener">https://forum.sentry.io/</a></p><h2 id="使用指南"><a href="#使用指南" class="headerlink" title="使用指南"></a>使用指南</h2><blockquote><p>PS: 进入Dashbord点击左上角头像，选择User settinng，然后在PREFEREBCES中，Language切换成简体中文，且Timezone调整至本地时区，不然后面看到监控的bug创建时间会有差别。</p></blockquote><h3 id="创建项目"><a href="#创建项目" class="headerlink" title="创建项目"></a>创建项目</h3><p>进入我们可以通过右上角 <strong>Add new… &gt; 项目</strong> 来创建，然后选择相应的项目，这里以vue为例子，如下图:</p><p><img src="https://raw.githubusercontent.com/blockfe/misc/gh-pages/xlogic/sentry_01.png" alt="sentry_01"></p><p>接下来会进入到<em>介绍页面</em>了，到这里第一步就算完成，<strong>请详细阅读该页面</strong>。</p><h3 id="前端项目部署"><a href="#前端项目部署" class="headerlink" title="前端项目部署"></a>前端项目部署</h3><p>切回本地项目,通过npm安装Sentry’s browser JavaScript SDK</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">npm install @sentry/browser</span><br><span class="line">npm install @sentry/integrations</span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> Vue <span class="keyword">from</span> <span class="string">'vue'</span></span><br><span class="line"><span class="keyword">import</span> * <span class="keyword">as</span> Sentry <span class="keyword">from</span> <span class="string">'@sentry/browser'</span>;</span><br><span class="line"><span class="keyword">import</span> * <span class="keyword">as</span> Integrations <span class="keyword">from</span> <span class="string">'@sentry/integrations'</span>;</span><br><span class="line"></span><br><span class="line">Sentry.init(&#123;</span><br><span class="line">  dsn: <span class="string">'https://xxxxxx/DSN'</span>, <span class="comment">// DSN密钥 - 应对后台项目</span></span><br><span class="line">  environment: <span class="string">'prod'</span>,  <span class="comment">// 项目环境 - 区分测试环境的和生产环境的异常</span></span><br><span class="line">  release: <span class="string">'1.0.0'</span>, <span class="comment">// Release版本控制 - 下文将会介绍</span></span><br><span class="line">  integrations: [</span><br><span class="line">    <span class="keyword">new</span> Integrations.Vue(&#123;</span><br><span class="line">      Vue,</span><br><span class="line">      attachProps: <span class="literal">true</span>,</span><br><span class="line">    &#125;),</span><br><span class="line">  ],</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>记得把DSN换成自己的，在<strong>介绍页面</strong>中可以找到，如果已经离开该页面，可以在<strong>项目 &gt; 设置 &gt; 客户端密钥(DSN)</strong>中找到它。</p><h3 id="自动捕捉异常-查看"><a href="#自动捕捉异常-查看" class="headerlink" title="自动捕捉异常+查看"></a>自动捕捉异常+查看</h3><p>ok，部署操作已经完成，接下来我们主动上报一个bug试试水。</p><p>在App.vue的mounted中写一个bug：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="built_in">window</span>.aaa.bbb());</span><br></pre></td></tr></table></figure><p>然后刷新页面触发bug，这时可以通过chrome调试工具查看上报异常的网络请求。</p><p><img src="https://raw.githubusercontent.com/blockfe/misc/gh-pages/xlogic/sentry_02.png" alt="sentry_02"></p><p>回到Sentry中，不出意外此时就可以看到相应的错误信息提示。</p><p><img src="https://raw.githubusercontent.com/blockfe/misc/gh-pages/xlogic/sentry_03.png" alt="sentry_03"></p><p>点进去后就能看到更多的错误信息还有用户信息，包括浏览器、版本、ip等</p><h3 id="主动捕捉异常"><a href="#主动捕捉异常" class="headerlink" title="主动捕捉异常"></a>主动捕捉异常</h3><p>通过上面的操作我们已经能成功监控到vue中的错误、异常，但是还不能捕捉到异步操作、接口请求中的错误，比如接口返回404、500等信息，此时我们可以通过Sentry.caputureException()进行主动上报。</p><h5 id="接口异常"><a href="#接口异常" class="headerlink" title="接口异常"></a>接口异常</h5><p>由于项目中常采用的axios进行接口请求，axios提供了请求响应的拦截器 axios.interceptors.response，示例：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">axios.interceptors.response.use(<span class="function"><span class="params">data</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> data;</span><br><span class="line">&#125;, error =&gt; &#123;</span><br><span class="line">    Sentry.captureException(error);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h5 id="异步操作"><a href="#异步操作" class="headerlink" title="异步操作"></a>异步操作</h5><p>在异步操作中的异常也不能被自动捕捉，我们需要手动处理：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">setTimeout(<span class="function"><span class="params">()</span>=&gt;</span>&#123;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">// do some</span></span><br><span class="line">  &#125; <span class="keyword">catch</span> (err) &#123;</span><br><span class="line">    Sentry.captureException(err);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;, <span class="number">1000</span>)<span class="string">`</span></span><br></pre></td></tr></table></figure><p>另外，请在主动抛出的异常时使用new error进行创建，这样能更好的定位异常所在位置。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// good </span></span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> error()</span><br><span class="line"></span><br><span class="line"><span class="comment">// bad</span></span><br><span class="line"><span class="keyword">throw</span> <span class="string">"error"</span></span><br></pre></td></tr></table></figure><h3 id="context-上下文信息"><a href="#context-上下文信息" class="headerlink" title="context 上下文信息"></a>context 上下文信息</h3><p>上下文信息包括：user、tags、level、fingerprint、extra data，这些信息我们可以通过在 scope 上面设置来定义。<br>其中可以通过两种方法得到 scope ：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 将 scope 配置到 context 上面</span></span><br><span class="line">Sentry.configureScope(<span class="function">(<span class="params">scope</span>) =&gt;</span> &#123; &#125;);</span><br><span class="line"><span class="comment">// 创建一个零时到 scope ，配置到 context 上面</span></span><br><span class="line">Sentry.withScope(<span class="function">(<span class="params">scope</span>) =&gt;</span> &#123; &#125;);</span><br></pre></td></tr></table></figure><h5 id="User"><a href="#User" class="headerlink" title="User"></a>User</h5><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">scope.setUser(&#123;</span><br><span class="line">  id:<span class="string">'1'</span>,</span><br><span class="line">  username:<span class="string">'xLogic'</span>,</span><br><span class="line">  ip_address:<span class="string">'127.0.0.1'</span>,</span><br><span class="line">  email: <span class="string">'xlogic@example.com'</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>其中user可以设置的信息包括id、username、ip_address、email。</p><h5 id="Tags"><a href="#Tags" class="headerlink" title="Tags"></a>Tags</h5><p>tags是给事件定义不同的键/值对，可以在查找的时候更容易。<br>后台查找的时候，查找选项会多出来一个选项，就是通过tags来设置的。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">scope.setTag(<span class="string">"page_local"</span>, <span class="string">"de-at"</span>);</span><br></pre></td></tr></table></figure><p>通过setTag来设置了一个page_local的标签, 后台会多一个page_local选项, 包括de-at。</p><h5 id="Extra-Data"><a href="#Extra-Data" class="headerlink" title="Extra Data"></a>Extra Data</h5><p>传入额外的信息, 并不会创建索引(也就是不可以提供来检索)。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">scope.setExtra(<span class="string">"character_name"</span>, <span class="string">"Mighty Fighter"</span>);</span><br></pre></td></tr></table></figure><h2 id="拓展功能"><a href="#拓展功能" class="headerlink" title="拓展功能"></a>拓展功能</h2><h3 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h3><p>需要安装Sentry对应的命令行管理工具 sentry-cli，方式如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm i -g @sentry/cli</span><br></pre></td></tr></table></figure><h5 id="生成token"><a href="#生成token" class="headerlink" title="生成token"></a>生成token</h5><p>点击Sentry页面左下角头像，选择API后就可以生成token，记得勾选 project:read, project:releases, project:write, project:admin 权限。</p><h5 id="登录"><a href="#登录" class="headerlink" title="登录"></a>登录</h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sentry-cli --url https://myserver/ login</span><br></pre></td></tr></table></figure><p>回车后输入上一步获得的 token 即可</p><h3 id="Release控制"><a href="#Release控制" class="headerlink" title="Release控制"></a>Release控制</h3><p>创建Release来进行“异常”的版本控制，此外下文提到的SoureceMap需通过Realease来标注版本，以匹配相应版本的源码，以便定位压缩前实际的错误信息。</p><h5 id="创建Release"><a href="#创建Release" class="headerlink" title="创建Release"></a>创建Release</h5><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sentry-cli releases -o 组织 -p 项目 new <span class="number">1.0</span><span class="number">.0</span></span><br></pre></td></tr></table></figure><p>-o : 组织，可以在我们的 <strong>组织设置</strong> 中找到 (sentry)</p><p>-p : 项目名称 ， 可以在 <strong>项目</strong> 中找到 (blokcfe)</p><p>这里的 1.0.0 就是我们指定的版本号，现在我们可以通过创建多个版本号来进行异常分类。<br>同时，也可以通过页面中”Releases”查看是否创建成功。</p><h5 id="本地应用Release"><a href="#本地应用Release" class="headerlink" title="本地应用Release"></a>本地应用Release</h5><p>回到前端项目中，在Sentry.init添加对应的release，指定版本后，每次上报的异常就会分类到该版本下。</p><h5 id="删除Release"><a href="#删除Release" class="headerlink" title="删除Release"></a>删除Release</h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sentry-cli releases -o 组织 -p 项目 delete 1.0.0</span><br></pre></td></tr></table></figure><p><em>注意:</em> 删除某个release时需要将其下的异常处理掉,并将该版本的SourceMap文件清空,完成上面两步可能还要等待2小时才能删除，不然会报错。</p><h3 id="SourceMap管理"><a href="#SourceMap管理" class="headerlink" title="SourceMap管理"></a>SourceMap管理</h3><p>目前来说，前端项目基本都会压缩混淆代码，这样导致Sentry捕捉到的异常堆栈无法理解。</p><p>我们希望在Sentry直接看到异常代码的源码时就需要上传对应的source和map。</p><h5 id="上传-SourceMap"><a href="#上传-SourceMap" class="headerlink" title="上传 SourceMap"></a>上传 SourceMap</h5><p><em>手动上传</em></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sentry-cli releases -o 组织 -p 项目 files 1.0.0 upload-sourcemaps jspath文件所在目录 --url-prefix 线上资源URI</span><br></pre></td></tr></table></figure><p>-o , -p : 和上文一样</p><p>jspath : js 文件的位置</p><p>uri : js 文件相对于域名的位置</p><p><em>Webpack Plugin上传</em></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm i -D @sentry/webpack-plugin</span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> SentryCliPlugin = <span class="built_in">require</span>(<span class="string">'@sentry/webpack-plugin'</span>);</span><br><span class="line">webpackConfig.plugins.push(</span><br><span class="line">  <span class="keyword">new</span> SentryCliPlugin(&#123;</span><br><span class="line">    release: <span class="number">1.0</span><span class="number">.0</span>,</span><br><span class="line">    include: path.join(__dirname, <span class="string">'../dist/static/js/'</span>), <span class="comment">// js 文件的位置</span></span><br><span class="line">    urlPrefix: <span class="string">'~/static/js'</span> <span class="comment">// js 文件相对于域名的位置</span></span><br><span class="line">  &#125;)</span><br><span class="line">);</span><br></pre></td></tr></table></figure><blockquote><p>PS: 需配置.sentryclirc，下文将详细介绍</p></blockquote><h5 id="清空-SourceMap-文件"><a href="#清空-SourceMap-文件" class="headerlink" title="清空 SourceMap 文件"></a>清空 SourceMap 文件</h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sentry-cli releases files 1.0.0 delete --all</span><br></pre></td></tr></table></figure><p>也可以选择在 版本&gt;工件 里点击一个个辣鸡桶进行删除</p><h5 id="重要的url-prefix"><a href="#重要的url-prefix" class="headerlink" title="重要的url-prefix"></a>重要的url-prefix</h5><p>这里的url-prefix可以通过线上看js文件的完整路径，有可能static不在根目录下</p><p>举例说明，项目线上资源URI如下：</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https:<span class="regexp">//</span>www.baidu.com<span class="regexp">/static/</span>js<span class="regexp">/test.js</span></span><br></pre></td></tr></table></figure><p>我们上传时文件的url-prefix就应该设置为 ‘~/static/js/‘</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https:<span class="regexp">//</span>www.baidu.com<span class="regexp">/assets/</span>aaa<span class="regexp">/js/</span>test.js</span><br></pre></td></tr></table></figure><p>我们上传时文件的url-prefix就应该设置为 ‘~/assets/aaa/js/‘</p><p><em>SourceMap上传完毕，就能在Sentry上直接看到出错源码位置了：</em></p><p><img src="https://raw.githubusercontent.com/blockfe/misc/gh-pages/xlogic/sentry_04.png" alt="sentry_04"></p><h3 id="报警邮件发送规则"><a href="#报警邮件发送规则" class="headerlink" title="报警邮件发送规则"></a>报警邮件发送规则</h3><p>Sentry默认会将所有采集到的异常发送警报邮件，有时我们可能希望只收到特定规则下的警报邮件，这时候就需要删除默认的警报规则，然后新建自定义规则。</p><p>一个比较常规的规则引擎，自己配置一下就可以搞定，还是比较简单。</p><h3 id="修改sentry-cli默认设置"><a href="#修改sentry-cli默认设置" class="headerlink" title="修改sentry-cli默认设置"></a>修改sentry-cli默认设置</h3><p>在上面的操作中，大家应该发现每次命令都需要重复输入一长串 -o xxx -p xxxx 来指定我们的项目，一点不DRY。</p><p>只需要找到当前用户文件夹下的 .sentryclirc 文件添加默认组织和项目即可，修改内容为如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[auth]</span><br><span class="line">token=YOUR API TOKEN</span><br><span class="line"></span><br><span class="line">[defaults]</span><br><span class="line">url=服务器</span><br><span class="line">org=组织</span><br><span class="line">project=项目</span><br></pre></td></tr></table></figure><h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>以上是我自己目前测试过功能，基本涵盖了常见场景。</p><p>当然，小伙们遇到问题或者新发现也可以跟我交流，一起挖掘更多使用场景。</p>]]></content>
    
    <summary type="html">
    
      Sentry是一款异常监控开源工具，名字翻译过来就是“哨兵”，在Github上面的简介是：“跨平台应用监控，关注错误报告”。
    
    </summary>
    
      <category term="Web开发" scheme="https://leaf930814.github.io/cates/Web%E5%BC%80%E5%8F%91/"/>
    
    
      <category term="Sentry" scheme="https://leaf930814.github.io/tags/Sentry/"/>
    
      <category term="前端监控" scheme="https://leaf930814.github.io/tags/%E5%89%8D%E7%AB%AF%E7%9B%91%E6%8E%A7/"/>
    
      <category term="Bug追踪" scheme="https://leaf930814.github.io/tags/Bug%E8%BF%BD%E8%B8%AA/"/>
    
  </entry>
  
  <entry>
    <title>JS异步编程的前世今生</title>
    <link href="https://leaf930814.github.io/notes/2018/05/17/JS%E5%BC%82%E6%AD%A5%E7%BC%96%E7%A8%8B%E7%9A%84%E5%89%8D%E4%B8%96%E4%BB%8A%E7%94%9F/"/>
    <id>https://leaf930814.github.io/notes/2018/05/17/JS异步编程的前世今生/</id>
    <published>2018-05-17T11:25:02.000Z</published>
    <updated>2019-10-16T04:11:52.464Z</updated>
    
    <content type="html"><![CDATA[<p>由于JavaScript是单线程的语言，因此异步编程对于js的重要程度可想而知，可以说没有异步的js程序寸步难行。本文是我在学习阮一峰大神的《深入掌握 ECMAScript 6 异步编程》以及《ES6标准入门》结合实际工作的收获，分享给广大网友共同学习。<br>什么是异步在这里就不赘述了，还不了解的小伙伴建议先去看看异步的概念。本文将以时间轴的顺序来讲述异步调用方案的演变，和我的一些感受。文中的一些代码以及部分概念会直接引用文章里的，毕竟在大神面前没有必要再班门弄斧了。</p><h4 id="最开始的异步实现方案–回调函数（callback）"><a href="#最开始的异步实现方案–回调函数（callback）" class="headerlink" title="最开始的异步实现方案–回调函数（callback）"></a>最开始的异步实现方案–回调函数（callback）</h4><p>最早的异步处理方案是回调函数，一段异步程序执行完成后，执行回调函数里的语句。如读取文件的处理:<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">fs.readFile(<span class="string">'/etc/passwd'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">err, data</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (err) <span class="keyword">throw</span> err;</span><br><span class="line">  <span class="built_in">console</span>.log(data);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p><p>回调函数最大的问题就是回调函数噩梦也叫回调地狱（callback hell）。接下来的一段代码，能让你深刻的体会到什么叫做回调地狱。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">fs.readFile(fileA, <span class="function"><span class="keyword">function</span> (<span class="params">err, data</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(err) <span class="keyword">throw</span> err</span><br><span class="line">  fs.readFile(fileB, <span class="function"><span class="keyword">function</span> (<span class="params">err, data</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(err) <span class="keyword">throw</span> err</span><br><span class="line">    fs.readFile(fileC,<span class="function"><span class="keyword">function</span>(<span class="params">err,data</span>)</span>&#123;</span><br><span class="line">      fs.readFile(fileD,<span class="function"><span class="keyword">function</span>(<span class="params">err,data</span>)</span>&#123;</span><br><span class="line">        fs.readFile(fileE,<span class="function"><span class="keyword">function</span>(<span class="params">err,data</span>)</span>&#123;</span><br><span class="line">          <span class="built_in">console</span>.log(data)</span><br><span class="line">        &#125;)</span><br><span class="line">      &#125;)      </span><br><span class="line">    &#125;)  </span><br><span class="line">  &#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p><p>为了形象的体现出回调函数方法的弊端，这里特意用了好几层异步操作。要知道，在实际的程序里，异步的连续操作是很常见的现象。可以看到上面的代码有以下缺陷：<br>1、可读性和维护性惨不忍睹<br>2、很容易造成变量污染<br>但在我看来，这种写法也不是一无是处，至少它的语义化还是比较强的，让人容易理解和使用。<br>为了解决回调地狱这个问题，Promise对象应运而生。</p><h4 id="更好异步写法–promise"><a href="#更好异步写法–promise" class="headerlink" title="更好异步写法–promise"></a>更好异步写法–promise</h4><p>有了Promise，上面的代码就可以这样写：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> readFile = <span class="built_in">require</span>(<span class="string">'fs-readfile-promise'</span>);</span><br><span class="line"></span><br><span class="line">readFile(fileA)</span><br><span class="line">.then(<span class="function"><span class="params">data</span>=&gt;</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(data.toString());</span><br><span class="line">&#125;)</span><br><span class="line">.catch(<span class="function"><span class="params">err</span>=&gt;</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(err)</span><br><span class="line">&#125;)</span><br><span class="line">.then(<span class="function"><span class="params">()</span>=&gt;</span>&#123;</span><br><span class="line">  <span class="keyword">return</span> readFile(fileB);</span><br><span class="line">&#125;)</span><br><span class="line">.catch(<span class="function"><span class="params">err</span>=&gt;</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log()</span><br><span class="line">&#125;)</span><br><span class="line">.then(<span class="function"><span class="params">data</span>=&gt;</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(data.toString());</span><br><span class="line">&#125;)</span><br><span class="line">...</span><br></pre></td></tr></table></figure></p><p>这样写，很明显，代码的可读性提高了不止一个档次，各个异步操作一目了然。在引入了ES6的新语法后，更是简洁明了。<br>Promise确实很好的解决了回调地狱的问题，目前也已经很广泛的在使用，像我的工作中大部分场合的异步就是用promise。<br>但是在我看来它的缺点是不太好理解，也可以说成不够语义化，至少我在刚开始接触的时候，花了很长一段时间才搞清楚Promise对象和then的用法。<br>另外一点，引用阮老师的说法，Promise写法只能算是回调函数的改进，只是提高了代码的可维护性，除此之外，并无新意，也就是说，它没有从思想上去改进异步编程的实现方案。</p><h4 id="新一代异步方案–Generator函数"><a href="#新一代异步方案–Generator函数" class="headerlink" title="新一代异步方案–Generator函数"></a>新一代异步方案–Generator函数</h4><p>Genorator函数形式如下:<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">gen</span>(<span class="params">x</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">var</span> y = <span class="keyword">yield</span> x + <span class="number">2</span>;</span><br><span class="line">  <span class="keyword">return</span> y;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>其中yield是一个命令，英文直译是“产出”的意思。Generator函数的调用方法和普通的一样，函数名后面接括号就可以调用。但它和普通函数的区别是，调用这个函数不会直接执行函数语句，而是返回一个指针对象。对这个指针对象使用next()方法，才能真正执行函数里的语句。<br>比如，如下的代码:<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> g = gen(<span class="number">1</span>);</span><br><span class="line">g.next() <span class="comment">// &#123; value: 3, done: false &#125;</span></span><br><span class="line">g.next() <span class="comment">// &#123; value: undefined, done: true &#125;</span></span><br></pre></td></tr></table></figure></p><p>gen(1)调用的时候，不会执行gen()函数里的任何语句，仅仅只是返回一个指针。只有当g.next()被调用的时候，才会开始执行函数体里面的语句。<br><em>这里需要澄清一下语句和表达式的区别。在我看来，所谓程序，就是输入+输出+控制三个过程。表达式就是一个提供或者不提供输入，然后按照一定的处理逻辑得到输出的短语。如3+2，就是给出3和2两个输入值，按照相加的逻辑得到5的输出，或者直接是一个值的形式，也是一个表达式，这个表达式的输入是这个值，处理逻辑是什么都不做，所以输出也是自己。或者是一个函数调用，填入参数作为输入或者不填参数，函数体作为一个集成的处理逻辑，最后得到函数的返回值。而语句，顾名思义，是一个完整的任务执行过程，也就是控制的过程，一般里面会包含了很多的表达式，比如赋值操作，声明变量，if语句，循环语句等等。当然，以上只是鄙人的大致理解，有不妥当和不准确之处，敬请见谅。</em><br>yield命令需要放在语句之中，独立的表达式之前。如前面的var y=yield x+2，显然x+2是一个表达式，y=x+2是一个语句。<br>如果把yield放在js语句之前，就会报错，如:<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">yield</span> y=x+<span class="number">2</span><span class="comment">//Uncaught SyntaxError</span></span><br></pre></td></tr></table></figure></p><p>如果把yield放在js表达式之中，也会报错<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">y=x+<span class="keyword">yield</span> <span class="number">2</span><span class="comment">//Uncaught SyntaxError</span></span><br></pre></td></tr></table></figure></p><p>如果给表达式之中加个括号，就可以：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">y=x+(<span class="keyword">yield</span> <span class="number">2</span>)<span class="comment">//正确</span></span><br></pre></td></tr></table></figure></p><p>因为加了括号后，括号里面就算是一个独立的表达式了，那么yield自然就是算放在了表达式的前面而不是中间了。</p><p>g.next()方法被调用后，函数体里的语句开始执行，从第一句开始依次往下执行，跟普通的js语句是一样的，这时，遇到了第一个有yield命令的语句。<br>此时，从这条包含yield的语句开始，下面的语句都会暂停执行，包括这条包含yield的语句本身，也不会执行。<br>此时g.next()返回的是一个对象，对象里包含了两个属性。value属性返回的是yield命令紧跟的后面的表达式返回的值，done表达式表示函数体里面的语句是否已经执行完。<br>这里需要注意的是，对象里的value虽然是yield命令后面表达式的返回值，但这并不是说包含yield的那条语句就执行了，相反，那条语句并没有执行，或者可以简单地理解为，仅仅只有yield的后面的表达式执行了。<br>然后，再调用一次g.next()方法，函数体会接着包含yield的语句的下面的一条语句继续执行，直到遇到下一个下一个包含yield的语句，函数体再次暂停，如果没有再次遇到，则一直执行完，返回一个和前面一样形式的包含value和yield的对象，如果函数里有return，则value是return后面的表达式的值，如没有没有return，则value是undefined。此时属性done的值为true，表示函数体已经全部执行完。接下来，调用g.next()方法都是返回{value:undefined,done:true}对象。<br>再次把整个函数和整个执行过程以及结果贴一遍以方便查看，因为接下来我想讨论一个问题。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">gen</span>(<span class="params">x</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">var</span> y = <span class="keyword">yield</span> x + <span class="number">2</span>;</span><br><span class="line">  <span class="keyword">return</span> y;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> g=gen(<span class="number">1</span>)</span><br><span class="line">g.next()<span class="comment">//&#123;value:3,done:false&#125;</span></span><br><span class="line">g.next()<span class="comment">//&#123;value:undefined,done:true&#125;</span></span><br></pre></td></tr></table></figure></p><p>请仔细看两次的g.next()结果，第一次的value是3，没有问题，是x+2返回的值，但是，请看第二次返回的结果，value竟然是undefined!要知道，函数明明是有返回值的，那就是y，而y是等于x+2的，也就是应该是3的，为什么是undefined呢？<br><strong>以下，是我的解释。<br>之所以明明有返回值y，却得到的是undefined，是因为，包含yield命令的那一句语句，会被拆分开来，yield与后面的表达式一起合成了一个语句，这个语句的执行结果就是在g.next()方法调用后返回一个对象，然后把表达式的值存进对象的value属性里。而语句执行完了之后，显然是只会返回undefined的，这也就意味着在函数体内y=yield x+2这句话，就变成了y=undefined了，看到这里，相信大家会有疑惑了，那这样的赋值还有什么意义？其实刚刚我的就是只说了一半，另一半还没有说，接下来就是另一半了。前面说第一次调用g.next()方法后，函数体内部就好比变成了y=undefined,这时是没有问题的，但是玄妙之处就在下一次的g.next()调用，先直接说现象,第二次如果我传一个参数给next呢，也就是调用g.next(5)呢，结果是返回了一个{value:5,done:true}对象，也就是说，在下一次调用g.next()的时候，如果传入参数，那么参数就会替换上一次的yield和后面表达式组成的语句执行结果的值，也就是undefined的值，所以就变成了y=5，那么自然后面返回的y的值就是5了。<br>换一句话来说，如果想要按照函数体的语句来正常执行的话，那么应该这么写:</strong><br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">gen</span>(<span class="params">x</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">var</span> y = <span class="keyword">yield</span> x + <span class="number">2</span>;</span><br><span class="line">  <span class="keyword">return</span> y;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> g=gen(<span class="number">1</span>)</span><br><span class="line"><span class="keyword">var</span> result1=g.next()</span><br><span class="line"><span class="built_in">console</span>.log(result1)<span class="comment">//&#123;value:3,done:false&#125;</span></span><br><span class="line"><span class="keyword">var</span> result2=g.next(result1.value)</span><br><span class="line"><span class="built_in">console</span>.log(result2)<span class="comment">//&#123;value:3,done:true&#125;</span></span><br></pre></td></tr></table></figure></p><p>也就是说把前面一次执行的该有的结果再传进第二次的next参数里面。</p><p>这个机制虽然在一开始有点不习惯，但是它是很有好处的，那就是可以在generator函数运行的不同阶段往里面动态的注入自己想要传入的值。<br><strong>注：第一次使用next方法时，往里面传入的值是无效的。</strong></p><p>generator函数的优点是引入了新的协程的概念，使代码的写法几乎与同步没有什么区别，另外也使代码更易于阅读和理解，能一眼就看出哪些地方有异步的操作，以及对异步做怎样的处理。但generator的缺点也很明显，那就是很原生（自己的理解），对于函数里的执行时机需要完全自己去写逻辑控制，需要自己判断什么时候异步操作执行完成，然后还要自己去调用下一步的操作，总的来说就是不够智能。</p><h5 id="co模块"><a href="#co模块" class="headerlink" title="co模块"></a>co模块</h5><p>co模块就是一个智能的generator自动执行器,只需要把generator函数传入co函数，函数体内的语句就能自动执行，完全不用考虑执行时机的问题。co函数返回一个Promise对象，因此还可以用then方法来添加回调函数.使用起来很简单:<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> gen = <span class="function"><span class="keyword">function</span>* (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> f1 = <span class="keyword">yield</span> readFile(<span class="string">'/etc/fstab'</span>);</span><br><span class="line">  <span class="keyword">var</span> f2 = <span class="keyword">yield</span> readFile(<span class="string">'/etc/shells'</span>);</span><br><span class="line">  <span class="built_in">console</span>.log(f1.toString());</span><br><span class="line">  <span class="built_in">console</span>.log(f2.toString());</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> co = <span class="built_in">require</span>(<span class="string">'co'</span>);</span><br><span class="line">co(gen).then(<span class="function"><span class="keyword">function</span> (<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'Generator 函数执行完成'</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p><p><strong>处理并发的异步操作</strong><br>并发的异步就是说几个异步同时开始进行，而不是排队一个一个进行。写法如下：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">co(<span class="function"><span class="keyword">function</span>* (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> res = <span class="keyword">yield</span> [</span><br><span class="line">    <span class="built_in">Promise</span>.resolve(<span class="number">1</span>),</span><br><span class="line">    <span class="built_in">Promise</span>.resolve(<span class="number">2</span>)</span><br><span class="line">  ];</span><br><span class="line">  <span class="built_in">console</span>.log(res);</span><br><span class="line">&#125;).catch(onerror);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 对象的写法</span></span><br><span class="line">co(<span class="function"><span class="keyword">function</span>* (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> res = <span class="keyword">yield</span> &#123;</span><br><span class="line">    <span class="number">1</span>: <span class="built_in">Promise</span>.resolve(<span class="number">1</span>),</span><br><span class="line">    <span class="number">2</span>: <span class="built_in">Promise</span>.resolve(<span class="number">2</span>),</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="built_in">console</span>.log(res);</span><br><span class="line">&#125;).catch(onerror);</span><br></pre></td></tr></table></figure></p><h4 id="终极异步方案（或许）–async函数"><a href="#终极异步方案（或许）–async函数" class="headerlink" title="终极异步方案（或许）–async函数"></a>终极异步方案（或许）–async函数</h4><p>引用阮老师原文对async的描述：</p><blockquote><p>async 函数是什么？一句话，它就是 Generator 函数的语法糖。</p><ol><li>内置执行器<br>Generator 函数的执行必须靠执行器，所以才有了co模块，而async函数自带执行器。也就是说，async函数的执行，与普通函数一模一样，只要一行。</li><li>更好的语义<br>async和await，比起星号和yield，语义更清楚了。async表示函数里有异步操作，await表示紧跟在后面的表达式需要等待结果。</li><li>更广的适用性<br>co模块约定，yield命令后面只能是 Thunk 函数或 Promise 对象，而async函数的await命令后面，可以是Promise 对象和原始类型的值（数值、字符串和布尔值，但这时等同于同步操作）。</li><li>返回值是Promise<br>async函数的返回值是 Promise 对象，这比 Generator 函数的返回值是 Iterator 对象方便多了。你可以用then方法指定下一步的操作。</li></ol></blockquote><h5 id="async函数的使用"><a href="#async函数的使用" class="headerlink" title="async函数的使用"></a>async函数的使用</h5><p>async函数的使用也非常简单:<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">timeout</span>(<span class="params">ms</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">await</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve</span>) =&gt;</span> &#123;</span><br><span class="line">    setTimeout(resolve, ms);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">asyncPrint</span>(<span class="params">value, ms</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">await</span> timeout(ms);</span><br><span class="line">  <span class="built_in">console</span>.log(value);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">asyncPrint(<span class="string">'hello world'</span>, <span class="number">50</span>);</span><br></pre></td></tr></table></figure></p><p>最后，贴出使用async函数的注意点:</p><ol><li>正常情况下，await命令后面是一个 Promise对象。如果不是，会被转成一个立即resolve的 Promise 对象。所以运行结果可能是rejected，最好把await命令放在try…catch代码块中。</li><li><p>多个await命令后面的异步操作，如果不存在继发关系，最好让它们同时触发。有以下两种写法:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">// 写法一,比较好理解</span></span><br><span class="line"><span class="keyword">let</span> [foo, bar] = <span class="keyword">await</span> <span class="built_in">Promise</span>.all([getFoo(), getBar()]);</span><br><span class="line"><span class="comment">// 写法二，结构更加清晰</span></span><br><span class="line"><span class="keyword">let</span> fooPromise = getFoo();</span><br><span class="line"><span class="keyword">let</span> barPromise = getBar();</span><br><span class="line"><span class="keyword">let</span> foo = <span class="keyword">await</span> fooPromise;</span><br><span class="line"><span class="keyword">let</span> bar = <span class="keyword">await</span> barPromise;</span><br></pre></td></tr></table></figure></li><li><p>await命令只能用在async函数之中，如果用在普通函数，就会报错</p></li></ol><p>关于更多关于异步编程的一些实现原理和细节的东西，阮一峰老师的es6入门教程和博客里写得非常详尽，就不再班门弄斧了。<br>最后，再次感谢阮老师的教程，让我受益匪浅。</p>]]></content>
    
    <summary type="html">
    
      由于JavaScript是单线程的语言，因此异步编程对于js的重要程度可想而知，可以说没有异步的js程序寸步难行。
    
    </summary>
    
      <category term="总结" scheme="https://leaf930814.github.io/cates/%E6%80%BB%E7%BB%93/"/>
    
    
      <category term="异步编程" scheme="https://leaf930814.github.io/tags/%E5%BC%82%E6%AD%A5%E7%BC%96%E7%A8%8B/"/>
    
  </entry>
  
</feed>
