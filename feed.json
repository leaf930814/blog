{"title":"leaf++ blog","description":null,"language":"zh-cn","link":"https://leaf930814.github.io","pubDate":"Fri, 20 Sep 2019 14:25:00 GMT","lastBuildDate":"Wed, 16 Oct 2019 04:12:29 GMT","generator":"hexo-generator-json-feed","webMaster":"leaf","items":[{"title":"《白帽子讲WEB安全》读书笔记","link":"https://leaf930814.github.io/notes/2019/09/20/《白帽子讲WEB安全》读书笔记/","description":"第1章 我的安全世界观安全评估的过程，可以简单分为 4 个阶段：资产等级划分、威胁分析、风险分析、确认解决方案。 Secure By Default 原则、纵深防御原则、数据与代码分离原则、不可预测性原则 第2章 浏览器安全同源策略是浏览器安全基础 浏览器沙箱：让不可信任代码运行在一定环境中，限制访问隔离区之外的资源 恶意网址拦截 第3章 跨站脚本攻击（XSS）Cross Site Script简介 概念：黑客通过“HTML注入”篡改网页，插入恶意脚本，从而在用户浏览网页时，控制用户浏览器。 根据效果分类： 反射型XSS：简单地把用户输入的数据反射给浏览器。 存储型XSS：会把用户输入的数据存储在服务器端，这种XSS具有稳定性。XSS攻击进阶 构造技巧： 利用字符编码 绕过长度限制 使用标签 Window.name:可以实现跨域，跨页面传递数据 防御 HttpOnly,解决cookie劫持 浏览器filter 输出检查：编码，转义 第4章 跨站点请求伪造（CSRF） 通过伪装来自受信任用户的请求来利用受信任的网站CSRF进阶 浏览器cookie：一种是Session Cookie，没有指定expire，浏览器关闭，cookie就失效，另一种是Third-party-Cookie，又称为本地cookie，只有expire时间到了后才会失效。 如果当前浏览器会拦截本地cookie，那就需要攻击者构造攻击环境，诱使用户在浏览器中先访问目标站点，使session cookie生效，再进行CSRF攻击 如果网站返回给浏览器的HTTP头中携带有P3P头，将允许浏览器发送第三方Cookie，即使在ie下也不会拦截。但是由于cookie是以域和path为单位的，p3p头的设置会影响整个域的所有页面。 不仅是get，CSRF也可以发起post请求 防御： 验证码：最简洁有效的防御手段，但是用户体验差。 Referer Check：也可以被用于检查请求是否来自合法的源，但是服务器端并不是任何时候都可以获取到Referer，所以不能作为主要防御手段。 Anti Csrf token：使用token是业界一致的做法，token的生成需要具有随机性和保密性 第5章 点击劫持（ClickJacking） 拖拽劫持 数据窃取 触屏劫持 防御：JavaScript禁止iframe嵌套 HTTP头X-Frame-Options iframe 可设置 sandbox 参数 第6章 HTML5 安全 HTML5新标签的XSS：可能带来新的XSS攻击。 注入攻击 两个关键条件：第一个是用户能够控制输入，第二个是原本程序要执行的代码，拼接了用户输入的数据。SQL注入 发现漏洞方式 攻击者通过web服务器的错误回显构造sql注入语句 没有错误回显一样可以实现注入，就是所谓的盲注，是通过简单的条件判断对比返回结果来发现漏洞。 防御 建立数据库账号时要遵循“最小权限”原则，每个应用分配不同的账号，且账号不应该具有创建自定义函数和操作本地文件的权限 使用预编译语句：这是防御sql注入的最佳方式，攻击者无法改变sql语句的结构 使用存储过程：但是存储过程也存在注入风险，所以应避免在存储过程中使用动态语句 检查数据类型：比如限制输入为Intger类型，比如限制输入为日期格式等其他注入攻击 XML注入 代码注入 CRLF注入","pubDate":"Fri, 20 Sep 2019 14:25:00 GMT","guid":"https://leaf930814.github.io/notes/2019/09/20/《白帽子讲WEB安全》读书笔记/","category":"Web开发"},{"title":"椭圆曲线加密原理与应用","link":"https://leaf930814.github.io/notes/2019/08/12/椭圆曲线加密原理与应用/","description":"一. 概述由于RSA、AES等国际算法面临高强度算法禁售和被部署后门风险，我国基于ECC椭圆曲线，自研SM2/SM3/SM4/SM9一套安全算法。根据国家整体战略，金融及重要领域要逐步实现国密算法替换，另根据人民银行总体规划，在2022年金融行业要全面应用国密算法。 在FireFly移动金融开发平台中，完善的提供了支持国密算法的加解密算法包。为了更好的使用和推广国密算法，下面具体分析ECC椭圆曲线的加密原理。 二. 椭圆曲线算法原理椭圆曲线(Elliptic Curve Cryptography)加密算法是一种公钥加密技术，以椭圆曲线理论为基础。利用有限域上椭圆曲线的点构成的Abel群离散对数难解性，实现加密、解密和数字签名。将椭圆曲线中的加法运算与离散对数中的模乘运算相对应，就可以建立基于椭圆曲线的对应密码体制。 三. 椭圆曲线算法优势 1. 更适合于移动互联网在同等加密安全强度下，ECC密钥长度为163bit，而RSA密钥长度为1024bit。ECC加密算法的密钥长度很短，意味着占用更少的存储空间，更低的CPU开销和占用更少的带宽。随着越来越多的用户使用移动设备来完成各种网上活动，ECC加密算法为移动互联网安全提供更好的客户体验。 2. 更好的安全性ECC加密算法提供更强的保护，比目前的其他加密算法能更好的防止攻击，使你的网站和基础设施比用传统的加密方法更安全，为移动互联网安全提供更好的保障。 3. 更好的性能ECC加密算法需要较短的密钥长度来提供更好的安全。 四.椭圆曲线理论基础1. 定义一条椭圆曲线是在射影平面上满足方程 Y2Z + a1XYZ + a3Yz2 = X3+ a2X2Z + a4XZ2 + a5Z3 所有点的集合，且曲线上的每个点都是非奇异（或光滑）的。 该方程是Weierstrass方程，是一个齐次方程。 椭圆曲线的形状，并不是椭圆的。只是因为椭圆曲线的描述方程，类似于计算一个椭圆周长的方程，故得名。下面是椭圆曲线的形状： 由椭圆曲线的定义可以知道，椭圆曲线是光滑的，所以椭圆曲线上的平常点都有切线。 2. 椭圆曲线上的加法① 运算法则 任意取椭圆曲线上两点P、Q （若P、Q两点重合，则做P点的切线）做直线交于椭圆曲线的另一点R’，过R’做y轴的平行线交于R。我们规定P+Q=R。（如图） ② 运算法则详解 这里的+是从普通加法中抽象出来的加法，他具备普通加法的一些性质，但具体的运算法则显然与普通加法不同。 k个相同的点P相加，我们记作kP。如下图：P+P+P = 2P+P = 3P，3P即为P点的3倍点。 3. 有限域上的椭圆曲线① 有限域 前面讲到的椭圆曲线是定义在实数域上的，实数是连续的，导致了椭圆曲线的连续，但是并不适合用于加密。所以，必须把椭圆曲线变成离散的点，需要把椭圆曲线定义在有限域上（顾名思义，有限域是一种只有由有限个元素组成的域）。 下面，给出一个有限域Fp，这个域只有有限个元素。 Fp中只有p（p为素数）个元素0,1,2 …… p-2,p-1； Fp 的加法（a+b）法则是a+b≡c (mod p)；即(a+b)÷p的余数和c÷p的余数相同。 Fp 的乘法(a×b)法则是 a×b≡c (mod p)； Fp 的除法(a÷b)法则是 a/b≡c (mod p)；即a×b-1≡c (mod p)；（b-1也是一个0到p-1之间的整数，但满足b×b-1≡1 (mod p)； Fp 的单位元是1，零元是0。 ② 可加密椭圆曲线 同时，并不是所有的椭圆曲线都适合加密。y2 = x3 + ax + b是一类可以用来加密的椭圆曲线，也是最为简单的一类。下面就把 y2 = x3 + ax + b这条曲线定义在Fp上： 选择两个满足下列条件的小于p(p为素数)的非负整数a、b 4a3 + 27b2 ≠ 0 (mod p) 则满足下列方程的所有点(x,y)，再加上无穷远点O∞ ，构成一条椭圆曲线。 y2 = x3 + ax + b(mod p) 其中x,y属于0到p-1间的整数，并将这条椭圆曲线记为Ep(a,b)。 示例：查看 y2 = x3 + x + 1 (mod 23)的图像 这样椭圆曲线，就成了一个一个离散的点，椭圆曲线在不同的数域中会呈现出不同的样子，但其本质仍是一条椭圆曲线。 ③ 计算椭圆曲线上点的坐标 Fp上的椭圆曲线同样有加法，根据加法法则，可以计算出椭圆曲线上点的坐标。 已知点P(x1, y1), Q(x2,y2)，计算点R(x3, y3)： X3 ≡ k2 – x1 – y1 (mod p) Y3 ≡ k(x1–x3) –y1 (mod p) 若P≠Q，PQR三点共线，其斜率 k=(y2–y1) / (x2 –x1) 。 其中若P=Q，PR为过P点的椭圆切线，其斜率 k=(3x12+ a) / 2y1 ④ 椭圆曲线上的点的阶 如果椭圆曲线上一点P，存在最小的正整数n，使得数乘nP=O∞，则将n称为P的阶，若n不存在，我们说P是无限阶的。事实上，在有限域上定义的椭圆曲线上所有的点的阶n都是存在的。 五. 椭圆曲线加解密原理1. 加解密依据公开密钥算法总是要基于一个数学上的难题。比如RSA依据的是：给定两个素数p、q 很容易相乘得到n，而对n进行因式分解却相对困难。那椭圆曲线上有什么难题呢？ 考虑如下等式： K=kG [其中K,G为Ep(a,b)上的点，k为小于n（n是点G的阶）的整数] 给定k和G，根据加法法则，计算K很容易；但给定K和G，求k就相对困难了。这就是椭圆曲线加密算法采用的难题。 我们把点G称为基点（base point），k（k&lt;n，n为基点G的阶）称为私有密钥（privte key），K称为公开密钥（public key)。 k = 2，K为G的2倍点; k = 3，K为G的3倍点; k = 4，K为G的4倍点; … 如果给定椭圆曲线上K为G的一个倍点，如何计算K为G的多少倍？直观上理解，正向计算一个倍点是容易的，反向计算一个点K是G的几倍点则困难的多。因此在椭圆曲线算法中，将倍数k做为私钥，将K做为公钥。 2. 加解密过程现在我们描述一个利用椭圆曲线进行加密通信的过程： 用户A选定一条椭圆曲线Ep(a,b)，并取椭圆曲线上一点，作为基点G。 用户A选择一个私有密钥k，并生成公开密钥K=kG。 用户A将Ep(a,b)和点K，G传给用户B。 用户B接到信息后，将待传输的明文编码到Ep(a,b)上一点M（编码方法很多，这里不作讨论），并产生一个随机整数r（r&lt;n）。 用户B计算点C1=M+rK；C2=rG。 用户B将C1、C2传给用户A。 用户A接到信息后，计算C1-kC2，结果就是点M。因为 C1-kC2=M+rK-k(rG)=M+rK-r(kG)=M 再对点M进行解码就可以得到明文。 在这个加密通信中，如果有一个偷窥者H ，他只能看到Ep(a,b)、K、G、C1、C2而通过K、G 求k 或通过C2、G求r 都是相对困难的。因此，H无法得到A、B间传送的明文信息。 3. 加解密参数密码学中，描述一条Fp上的椭圆曲线，常用到六个参数： T=(p,a,b,G,n,h)。 p 、a 、b 用来确定一条椭圆曲线， G为基点， n为点G的阶， h 是椭圆曲线上所有点的个数m与n相除的整数部分。 这几个参数取值的选择，直接影响了加密的安全性。参数值一般要求满足以下几个条件： p 当然越大越安全，但越大，计算速度会变慢，200位左右可以满足一般安全要求； p≠n×h； pt≠1 (mod n)，1≤t&lt;20； 4a3 + 27b2 ≠ 0 (mod p)； n 为素数； h≤4。 六.椭圆曲线数字签名原理(ECDSA)1. 概述椭圆曲线数字签名算法（ECDSA）是使用椭圆曲线密码（ECC）对数字签名算法（DSA）的模拟。 ECDSA是ECC与DSA的结合，整个签名过程与DSA类似，所不一样的是签名中采取的算法为ECC，最后签名出来的值也是分为r,s。 2. 签名过程 选择一条椭圆曲线Ep(a,b)，和基点G； 选择私有密钥k（k&lt;n，n为G的阶），利用基点G计算公开密钥K=kG； 产生一个随机整数r（r&lt;n），计算点R=rG； 将原数据和点R的坐标值x,y作为参数，计算SHA1做为hash，即Hash=SHA1(原数据,x,y)； 计算s≡r - Hash * k (mod n)； r和s做为签名值，如果r和s其中一个为0，重新从第3步开始执行。 3. 验签过程接受方在收到消息(m)和签名值(r,s)后，进行以下运算： 计算：sG+H(m)P=(x1,y1), r1≡x1 mod p。 验证等式：r1 ≡r mod p。 如果等式成立，接受签名，否则签名无效。 七.椭圆曲线算法应用椭圆加密算法的应用范围很广，如 TLS、openPGP以及SSH都在使用，在比特币以及其他加密数字货币中也得到广泛使用。另外我国重点推广的国密SM2算法也正是基于椭圆曲线算法。下面以SM2和TLS为例进行说明： 1. SM2① 概述 SM2算法和RSA算法都是公钥密码算法，随着密码技术和计算技术的发展，目前常用的1024位RSA算法面临严重的安全威胁，我们国家密码管理部门经过研究，决定采用SM2椭圆曲线算法替换RSA算法。SM2算法在安全性、性能上都具有优势，参见表1算法攻破时间，表2算法性能。 RSA密钥强度 椭圆曲线密钥强度 是否攻破 512 106 已被攻破 768 132 已被攻破 1024 160 - 2048 210 - 表1 算法攻破时间 算法 签名速度(次/秒) 验签速度(次/秒) 1024位RSA 2792 51224 2048位RSA 455 15122 256位SM2 4095 871 表2 算法性能 ② SM2和椭圆曲线算法之间的关系 SM2算法采用的椭圆曲线方程为：y2= x3+ ax + b,在SM2算法标准中，通过指定a、b系数，确定了唯一的标准曲线。同时，为了将曲线映射为加密算法，SM2标准中还确定了其它参数，供算法程序使用。 ③ SM2加解密过程 下面是SM2加解密流程中使用到的符号缩略语： A, B 使用公钥密码系统的两个用户。 dB 用户B 的私钥。 E(Fq) Fq 上椭圆曲线E 的所有有理点(包括无穷远点O)组成的集合。 Fq 包含q 个元素的有限域。 G 椭圆曲线的一个基点，其阶为素数。 Hash() 密码杂凑算法。 Hv( ) 消息摘要长度为v 比特的密码杂凑算法。 KDF( ) 密钥派生函数。 h 余因子，h=#E(Fq)/n，其中n 是基点G 的阶。 M 待加密的消息。 M’ 解密得到的消息。 n 基点G 的阶(n 是#E(Fq)的素因子)。 O 椭圆曲线上的一个特殊点，称为无穷远点或零点，是椭圆曲线加法群的单位元。 PB 用户B 的公钥。 q 有限域Fq 中元素的数目。 a, b Fq 中的元素，它们定义Fq 上的一条椭圆曲线E。 x||y x 与y 的拼接，x、y 是比特串或字节串。 [k]P 椭圆曲线上点P 的k 倍点。 E(Fq) E(Fq)上点的数目，称为椭圆曲线E(Fq)的阶。 M⊕t xor运算 a. 加密算法流程 SM2加密使用公钥加密，公钥由一个曲线坐标点组成，在X.509证书中的公钥表示为04标记开始的2个32byte的BigInteger，即曲线点P（x,y）。SM2公钥加密算法比RSA相对复杂，加密结果由3个部分组成，SM2加密过程中使用了随机数，因此同样的明文数据每一次加密结果都不一样。 设需要发送的消息为比特串M，klen 为M 的比特长度。 为了对明文M 进行加密，作为加密者的用户A 应实现以下运算步骤： A1：用随机数发生器产生随机数k∈[1, n-1]； A2：计算椭圆曲线点C1 = [k]G=(x1, y1)，按SM2 椭圆曲线公钥密码算法第1 部分3.2.9 和3.2.5 给 出的方法，将C1 的数据类型转换为比特串； A3：计算椭圆曲线点S= [h]PB，若S 是无穷远点，则报错并退出； A4：计算椭圆曲线点[k]PB=(x2, y2)，按SM2 椭圆曲线公钥密码算法第1 部分3.2.6 和3.2.5 给出的 方法，将坐标x2、y2 的数据类型转换为比特串； A5：计算t = KDF(x2||y2，klen)，若t 为全0 比特串，则返回A1； A6：计算C2=M⊕t； A7：计算C3= Hash (x2||M|| y2)； A8：输出密文C=C1||C3||C2。 根据国密推荐的SM2椭圆曲线公钥密码算法，首先产生随机数计算出曲线点C1，2个32byte的BigInteger大数，即为SM2加密结果的第1部分。第2部分则是真正的密文，是对明文的加密结果，长度和明文一样。第3部分是杂凑值，用来效验数据。按国密推荐的256位椭圆曲线，明文加密结果比原长度会大96byte。 b. 解密算法流程 SM2解密算法是加密逆运算。首先需要从密文中取出加密结果的3部分值，然后通过私钥计算出M’明文值，最后效验数据 设klen 为密文中C2 的比特长度。 为了对密文C=C1||C3||C2 进行解密，作为解密者的用户B 应实现以下运算步骤： B1：从C 中取出比特串C1，按SM2 椭圆曲线公钥密码算法第1 部分3.2.4 和3.2.10 给出的方法， 将C1 的数据类型转换为椭圆曲线上的点，验证C1 是否满足椭圆曲线方程，若不满足则报错 并退出； B2：计算椭圆曲线点S= [h]C1，若S 是无穷远点，则报错并退出； B3：计算[dB]C1= (x2, y2)，按SM2 椭圆曲线公钥密码算法第1 部分3.2.6 和3.2.5 给出的方法，将 坐标x2、y2 的数据类型转换为比特串； B4：计算t = KDF(x2||y2，klen)，若t 为全0 比特串，则报错并退出； B5：从C 中取出比特串C2，计算M’=C2⊕t； B6：计算u = Hash (x2||M’|| y2)，从C 中取出比特串C3，若u≠C3，则报错并退出； B7：输出明文M’。 SM2解密同样也可以使用软算法实现。但因为涉及到私钥运算，为保护私钥安全，建议在硬件设备中运行，例如UKey等存储介质这样可以更好的保护密钥安全。拿文件加密来说，首先拿UKey里面的加密证书加密，这部分可在应用系统内完成。解密的话则需要加密证书对应UKey才能做解密，由应用系统调用UKey解密接口，在物理硬件内完成数据解密，同时可以受设备PIN码保护。 ④ SM2算法的速度和结果长度 简单讲，SM2签名速度快，验签速度慢，这点和RSA算法的特性正好相反。参见上表2。另外，加解密速度和验签速度相当。 SM2支持近128G字节数据长度，加密结果增加96个字节。 SM2签名算法对原始数据量长度无限制，签名结果为64字节。 2. TLS① 概述 HTTPS 通过TLS 层和证书机制提供了内容加密、身份认证和数据完整性三大功能，可以有效防止数据被监听或篡改，还能抵御MITM（中间人）攻击。TLS 在实施加密过程中，需要用到非对称密钥交换和对称内容加密两大算法。对称内容加密强度非常高，加解密速度也很快，只是无法安全地生成和保管密钥。在TLS 协议中，应用数据都是经过对称加密后传输的，传输中所使用的对称密钥，则是在握手阶段通过非对称密钥交换而来。 ② TLS中密钥交换算法 目前最常用的密钥交换算法有RSA 和ECDHE：RSA 历史悠久，支持度好，但不支持PFS（Perfect Forward Secrecy）；而ECDHE 是使用了ECC（椭圆曲线）的DH（Diffie-Hellman）算法，计算速度快，支持PFS。 ③ 基于ECC的密钥交换算法 下面是五种常见的基于ECC的TLS 密钥交换算法，它们分别模仿DH_DSS，DHE_DSS，DH_RSA，DHE_RSA和DH_anon。 以ECDHE_ECDSA为例： 证书包含ECDSA-capable 公钥，使用ECDHE 算法协商预备主密钥; 证书必须允许密钥用于使用将在Server 密钥交换消息中使用的散列算法进行签名;公钥必须使用一个能够被Client 支持的曲线和点格式，Client 通过Client Hello 消息中的ec_point_formats 扩展指定支持的命名曲线，正如 [TLSECC] 中描述的那样。这是TLS 1.2 中最安全，性能最高的密码套件。 ④ ECDHE密钥交换的完整握手流程 A: 客户端向服务器发送Client Hello,告知服务器，客户端支持的协议版本、加密套件等信息。 B: a. 服务端收到响应，选择双方都支持的协议、套件，向客户端发送Server Hello，同时服务器也将自己的证书发送到客户端(Certificate)。 b. 服务器利用私钥将客户端随机数、服务器随机数、服务器DH参数签名，生成服务器签名。 C: 服务端向客户端发送服务器DH参数以及服务器签名(Server Key Exchange)。 D: 客户端向服务端发送客户端DH参数(Client Key Exchange)。 之后，客户端利用公钥验证服务器签名，客户端与服务器各自利用服务端DH参数、客户端DH参数生成预主密钥，再通过预主密钥、客户端随机数、服务端随机数生成主密钥(会话密钥)。最后握手完成，所有的消息都通过主密钥加密。如图： 八. 结语椭圆曲线ECC算法基于椭圆曲线理论，可以用较少的计算能力提供更高的安全强度，有效地解决了“提高安全强度必须增加密钥长度”的工程实现问题，且已经得到广泛的支持和使用，读者在选择加密算法时，ECC算法不失为一个优秀的选择。 九. 参考资料ECC加密算法入门介绍 https://www.pediy.com/kssd/pediy06/pediy6014.htm Elliptic Curve Cryptography: a gentle introduction https://andrea.corbellini.name/2015/05/17/elliptic-curve-cryptography-a-gentle-introduction/ 国家密码管理局 http://www.oscca.gov.cn/ 国家商用密码（一）SM2椭圆曲线公钥密码算法 http://www.firstsolver.com/wordpress/?p=1938 TLS_ECC https://tools.ietf.org/html/rfc4492","pubDate":"Mon, 12 Aug 2019 12:00:00 GMT","guid":"https://leaf930814.github.io/notes/2019/08/12/椭圆曲线加密原理与应用/","category":"Web开发"},{"title":"Sentry - 及时发现Bug，提高Debug效率","link":"https://leaf930814.github.io/notes/2019/05/16/to-improve-debug-efficiency/","description":"Sentry简介Sentry是一款异常监控开源工具，名字翻译过来就是“哨兵”，在Github上面的简介是：“跨平台应用监控，关注错误报告”。支持各种语言，例如 python、oc、java、node、javascript 等。也可以应用到各种不同的框架上面，如前端框架中的vue 、angular 、react 等最流行的前端框架。Sentry分为社区开源版和在线Saas版，这里我们已经在自己服务器部署了一套服务。 官网： https://sentry.io 文档： https://docs.sentry.io/clients/javascript/install/ Github仓库： https://github.com/getsentry/sentry 社区除了github issue外还可以关注 https://forum.sentry.io/ 使用指南 PS: 进入Dashbord点击左上角头像，选择User settinng，然后在PREFEREBCES中，Language切换成简体中文，且Timezone调整至本地时区，不然后面看到监控的bug创建时间会有差别。 创建项目进入我们可以通过右上角 Add new… &gt; 项目 来创建，然后选择相应的项目，这里以vue为例子，如下图: 接下来会进入到介绍页面了，到这里第一步就算完成，请详细阅读该页面。 前端项目部署切回本地项目,通过npm安装Sentry’s browser JavaScript SDK 12npm install @sentry/browsernpm install @sentry/integrations 123456789101112131415import Vue from 'vue'import * as Sentry from '@sentry/browser';import * as Integrations from '@sentry/integrations';Sentry.init(&#123; dsn: 'https://xxxxxx/DSN', // DSN密钥 - 应对后台项目 environment: 'prod', // 项目环境 - 区分测试环境的和生产环境的异常 release: '1.0.0', // Release版本控制 - 下文将会介绍 integrations: [ new Integrations.Vue(&#123; Vue, attachProps: true, &#125;), ],&#125;); 记得把DSN换成自己的，在介绍页面中可以找到，如果已经离开该页面，可以在项目 &gt; 设置 &gt; 客户端密钥(DSN)中找到它。 自动捕捉异常+查看ok，部署操作已经完成，接下来我们主动上报一个bug试试水。 在App.vue的mounted中写一个bug： 1console.log(window.aaa.bbb()); 然后刷新页面触发bug，这时可以通过chrome调试工具查看上报异常的网络请求。 回到Sentry中，不出意外此时就可以看到相应的错误信息提示。 点进去后就能看到更多的错误信息还有用户信息，包括浏览器、版本、ip等 主动捕捉异常通过上面的操作我们已经能成功监控到vue中的错误、异常，但是还不能捕捉到异步操作、接口请求中的错误，比如接口返回404、500等信息，此时我们可以通过Sentry.caputureException()进行主动上报。 接口异常由于项目中常采用的axios进行接口请求，axios提供了请求响应的拦截器 axios.interceptors.response，示例： 12345axios.interceptors.response.use(data =&gt; &#123; return data;&#125;, error =&gt; &#123; Sentry.captureException(error);&#125;) 异步操作在异步操作中的异常也不能被自动捕捉，我们需要手动处理： 1234567setTimeout(()=&gt;&#123; try &#123; // do some &#125; catch (err) &#123; Sentry.captureException(err); &#125;&#125;, 1000)` 另外，请在主动抛出的异常时使用new error进行创建，这样能更好的定位异常所在位置。 12345// good throw new error()// badthrow \"error\" context 上下文信息上下文信息包括：user、tags、level、fingerprint、extra data，这些信息我们可以通过在 scope 上面设置来定义。其中可以通过两种方法得到 scope ： 1234// 将 scope 配置到 context 上面Sentry.configureScope((scope) =&gt; &#123; &#125;);// 创建一个零时到 scope ，配置到 context 上面Sentry.withScope((scope) =&gt; &#123; &#125;); User123456scope.setUser(&#123; id:'1', username:'xLogic', ip_address:'127.0.0.1', email: 'xlogic@example.com'&#125;); 其中user可以设置的信息包括id、username、ip_address、email。 Tagstags是给事件定义不同的键/值对，可以在查找的时候更容易。后台查找的时候，查找选项会多出来一个选项，就是通过tags来设置的。 1scope.setTag(\"page_local\", \"de-at\"); 通过setTag来设置了一个page_local的标签, 后台会多一个page_local选项, 包括de-at。 Extra Data传入额外的信息, 并不会创建索引(也就是不可以提供来检索)。 1scope.setExtra(\"character_name\", \"Mighty Fighter\"); 拓展功能准备工作需要安装Sentry对应的命令行管理工具 sentry-cli，方式如下： 1npm i -g @sentry/cli 生成token点击Sentry页面左下角头像，选择API后就可以生成token，记得勾选 project:read, project:releases, project:write, project:admin 权限。 登录1$ sentry-cli --url https://myserver/ login 回车后输入上一步获得的 token 即可 Release控制创建Release来进行“异常”的版本控制，此外下文提到的SoureceMap需通过Realease来标注版本，以匹配相应版本的源码，以便定位压缩前实际的错误信息。 创建Release1sentry-cli releases -o 组织 -p 项目 new 1.0.0 -o : 组织，可以在我们的 组织设置 中找到 (sentry) -p : 项目名称 ， 可以在 项目 中找到 (blokcfe) 这里的 1.0.0 就是我们指定的版本号，现在我们可以通过创建多个版本号来进行异常分类。同时，也可以通过页面中”Releases”查看是否创建成功。 本地应用Release回到前端项目中，在Sentry.init添加对应的release，指定版本后，每次上报的异常就会分类到该版本下。 删除Release1sentry-cli releases -o 组织 -p 项目 delete 1.0.0 注意: 删除某个release时需要将其下的异常处理掉,并将该版本的SourceMap文件清空,完成上面两步可能还要等待2小时才能删除，不然会报错。 SourceMap管理目前来说，前端项目基本都会压缩混淆代码，这样导致Sentry捕捉到的异常堆栈无法理解。 我们希望在Sentry直接看到异常代码的源码时就需要上传对应的source和map。 上传 SourceMap手动上传 1sentry-cli releases -o 组织 -p 项目 files 1.0.0 upload-sourcemaps jspath文件所在目录 --url-prefix 线上资源URI -o , -p : 和上文一样 jspath : js 文件的位置 uri : js 文件相对于域名的位置 Webpack Plugin上传 1npm i -D @sentry/webpack-plugin 12345678const SentryCliPlugin = require('@sentry/webpack-plugin');webpackConfig.plugins.push( new SentryCliPlugin(&#123; release: 1.0.0, include: path.join(__dirname, '../dist/static/js/'), // js 文件的位置 urlPrefix: '~/static/js' // js 文件相对于域名的位置 &#125;)); PS: 需配置.sentryclirc，下文将详细介绍 清空 SourceMap 文件1sentry-cli releases files 1.0.0 delete --all 也可以选择在 版本&gt;工件 里点击一个个辣鸡桶进行删除 重要的url-prefix这里的url-prefix可以通过线上看js文件的完整路径，有可能static不在根目录下 举例说明，项目线上资源URI如下： 1https://www.baidu.com/static/js/test.js 我们上传时文件的url-prefix就应该设置为 ‘~/static/js/‘ 1https://www.baidu.com/assets/aaa/js/test.js 我们上传时文件的url-prefix就应该设置为 ‘~/assets/aaa/js/‘ SourceMap上传完毕，就能在Sentry上直接看到出错源码位置了： 报警邮件发送规则Sentry默认会将所有采集到的异常发送警报邮件，有时我们可能希望只收到特定规则下的警报邮件，这时候就需要删除默认的警报规则，然后新建自定义规则。 一个比较常规的规则引擎，自己配置一下就可以搞定，还是比较简单。 修改sentry-cli默认设置在上面的操作中，大家应该发现每次命令都需要重复输入一长串 -o xxx -p xxxx 来指定我们的项目，一点不DRY。 只需要找到当前用户文件夹下的 .sentryclirc 文件添加默认组织和项目即可，修改内容为如下： 1234567[auth]token=YOUR API TOKEN[defaults]url=服务器org=组织project=项目 结语以上是我自己目前测试过功能，基本涵盖了常见场景。 当然，小伙们遇到问题或者新发现也可以跟我交流，一起挖掘更多使用场景。","pubDate":"Thu, 16 May 2019 04:43:35 GMT","guid":"https://leaf930814.github.io/notes/2019/05/16/to-improve-debug-efficiency/","category":"Web开发"},{"title":"JS异步编程的前世今生","link":"https://leaf930814.github.io/notes/2018/05/17/JS异步编程的前世今生/","description":"由于JavaScript是单线程的语言，因此异步编程对于js的重要程度可想而知，可以说没有异步的js程序寸步难行。本文是我在学习阮一峰大神的《深入掌握 ECMAScript 6 异步编程》以及《ES6标准入门》结合实际工作的收获，分享给广大网友共同学习。什么是异步在这里就不赘述了，还不了解的小伙伴建议先去看看异步的概念。本文将以时间轴的顺序来讲述异步调用方案的演变，和我的一些感受。文中的一些代码以及部分概念会直接引用文章里的，毕竟在大神面前没有必要再班门弄斧了。 最开始的异步实现方案–回调函数（callback）最早的异步处理方案是回调函数，一段异步程序执行完成后，执行回调函数里的语句。如读取文件的处理:1234fs.readFile('/etc/passwd', function (err, data) &#123; if (err) throw err; console.log(data);&#125;) 回调函数最大的问题就是回调函数噩梦也叫回调地狱（callback hell）。接下来的一段代码，能让你深刻的体会到什么叫做回调地狱。12345678910111213fs.readFile(fileA, function (err, data) &#123; if(err) throw err fs.readFile(fileB, function (err, data) &#123; if(err) throw err fs.readFile(fileC,function(err,data)&#123; fs.readFile(fileD,function(err,data)&#123; fs.readFile(fileE,function(err,data)&#123; console.log(data) &#125;) &#125;) &#125;) &#125;)&#125;) 为了形象的体现出回调函数方法的弊端，这里特意用了好几层异步操作。要知道，在实际的程序里，异步的连续操作是很常见的现象。可以看到上面的代码有以下缺陷：1、可读性和维护性惨不忍睹2、很容易造成变量污染但在我看来，这种写法也不是一无是处，至少它的语义化还是比较强的，让人容易理解和使用。为了解决回调地狱这个问题，Promise对象应运而生。 更好异步写法–promise有了Promise，上面的代码就可以这样写：12345678910111213141516171819var readFile = require('fs-readfile-promise');readFile(fileA).then(data=&gt;&#123; console.log(data.toString());&#125;).catch(err=&gt;&#123; console.log(err)&#125;).then(()=&gt;&#123; return readFile(fileB);&#125;).catch(err=&gt;&#123; console.log()&#125;).then(data=&gt;&#123; console.log(data.toString());&#125;)... 这样写，很明显，代码的可读性提高了不止一个档次，各个异步操作一目了然。在引入了ES6的新语法后，更是简洁明了。Promise确实很好的解决了回调地狱的问题，目前也已经很广泛的在使用，像我的工作中大部分场合的异步就是用promise。但是在我看来它的缺点是不太好理解，也可以说成不够语义化，至少我在刚开始接触的时候，花了很长一段时间才搞清楚Promise对象和then的用法。另外一点，引用阮老师的说法，Promise写法只能算是回调函数的改进，只是提高了代码的可维护性，除此之外，并无新意，也就是说，它没有从思想上去改进异步编程的实现方案。 新一代异步方案–Generator函数Genorator函数形式如下:1234function* gen(x)&#123; var y = yield x + 2; return y;&#125; 其中yield是一个命令，英文直译是“产出”的意思。Generator函数的调用方法和普通的一样，函数名后面接括号就可以调用。但它和普通函数的区别是，调用这个函数不会直接执行函数语句，而是返回一个指针对象。对这个指针对象使用next()方法，才能真正执行函数里的语句。比如，如下的代码:123var g = gen(1);g.next() // &#123; value: 3, done: false &#125;g.next() // &#123; value: undefined, done: true &#125; gen(1)调用的时候，不会执行gen()函数里的任何语句，仅仅只是返回一个指针。只有当g.next()被调用的时候，才会开始执行函数体里面的语句。这里需要澄清一下语句和表达式的区别。在我看来，所谓程序，就是输入+输出+控制三个过程。表达式就是一个提供或者不提供输入，然后按照一定的处理逻辑得到输出的短语。如3+2，就是给出3和2两个输入值，按照相加的逻辑得到5的输出，或者直接是一个值的形式，也是一个表达式，这个表达式的输入是这个值，处理逻辑是什么都不做，所以输出也是自己。或者是一个函数调用，填入参数作为输入或者不填参数，函数体作为一个集成的处理逻辑，最后得到函数的返回值。而语句，顾名思义，是一个完整的任务执行过程，也就是控制的过程，一般里面会包含了很多的表达式，比如赋值操作，声明变量，if语句，循环语句等等。当然，以上只是鄙人的大致理解，有不妥当和不准确之处，敬请见谅。yield命令需要放在语句之中，独立的表达式之前。如前面的var y=yield x+2，显然x+2是一个表达式，y=x+2是一个语句。如果把yield放在js语句之前，就会报错，如:1yield y=x+2//Uncaught SyntaxError 如果把yield放在js表达式之中，也会报错1y=x+yield 2//Uncaught SyntaxError 如果给表达式之中加个括号，就可以：1y=x+(yield 2)//正确 因为加了括号后，括号里面就算是一个独立的表达式了，那么yield自然就是算放在了表达式的前面而不是中间了。 g.next()方法被调用后，函数体里的语句开始执行，从第一句开始依次往下执行，跟普通的js语句是一样的，这时，遇到了第一个有yield命令的语句。此时，从这条包含yield的语句开始，下面的语句都会暂停执行，包括这条包含yield的语句本身，也不会执行。此时g.next()返回的是一个对象，对象里包含了两个属性。value属性返回的是yield命令紧跟的后面的表达式返回的值，done表达式表示函数体里面的语句是否已经执行完。这里需要注意的是，对象里的value虽然是yield命令后面表达式的返回值，但这并不是说包含yield的那条语句就执行了，相反，那条语句并没有执行，或者可以简单地理解为，仅仅只有yield的后面的表达式执行了。然后，再调用一次g.next()方法，函数体会接着包含yield的语句的下面的一条语句继续执行，直到遇到下一个下一个包含yield的语句，函数体再次暂停，如果没有再次遇到，则一直执行完，返回一个和前面一样形式的包含value和yield的对象，如果函数里有return，则value是return后面的表达式的值，如没有没有return，则value是undefined。此时属性done的值为true，表示函数体已经全部执行完。接下来，调用g.next()方法都是返回{value:undefined,done:true}对象。再次把整个函数和整个执行过程以及结果贴一遍以方便查看，因为接下来我想讨论一个问题。1234567function* gen(x)&#123; var y = yield x + 2; return y;&#125;var g=gen(1)g.next()//&#123;value:3,done:false&#125;g.next()//&#123;value:undefined,done:true&#125; 请仔细看两次的g.next()结果，第一次的value是3，没有问题，是x+2返回的值，但是，请看第二次返回的结果，value竟然是undefined!要知道，函数明明是有返回值的，那就是y，而y是等于x+2的，也就是应该是3的，为什么是undefined呢？以下，是我的解释。之所以明明有返回值y，却得到的是undefined，是因为，包含yield命令的那一句语句，会被拆分开来，yield与后面的表达式一起合成了一个语句，这个语句的执行结果就是在g.next()方法调用后返回一个对象，然后把表达式的值存进对象的value属性里。而语句执行完了之后，显然是只会返回undefined的，这也就意味着在函数体内y=yield x+2这句话，就变成了y=undefined了，看到这里，相信大家会有疑惑了，那这样的赋值还有什么意义？其实刚刚我的就是只说了一半，另一半还没有说，接下来就是另一半了。前面说第一次调用g.next()方法后，函数体内部就好比变成了y=undefined,这时是没有问题的，但是玄妙之处就在下一次的g.next()调用，先直接说现象,第二次如果我传一个参数给next呢，也就是调用g.next(5)呢，结果是返回了一个{value:5,done:true}对象，也就是说，在下一次调用g.next()的时候，如果传入参数，那么参数就会替换上一次的yield和后面表达式组成的语句执行结果的值，也就是undefined的值，所以就变成了y=5，那么自然后面返回的y的值就是5了。换一句话来说，如果想要按照函数体的语句来正常执行的话，那么应该这么写:123456789function* gen(x)&#123; var y = yield x + 2; return y;&#125;var g=gen(1)var result1=g.next()console.log(result1)//&#123;value:3,done:false&#125;var result2=g.next(result1.value)console.log(result2)//&#123;value:3,done:true&#125; 也就是说把前面一次执行的该有的结果再传进第二次的next参数里面。 这个机制虽然在一开始有点不习惯，但是它是很有好处的，那就是可以在generator函数运行的不同阶段往里面动态的注入自己想要传入的值。注：第一次使用next方法时，往里面传入的值是无效的。 generator函数的优点是引入了新的协程的概念，使代码的写法几乎与同步没有什么区别，另外也使代码更易于阅读和理解，能一眼就看出哪些地方有异步的操作，以及对异步做怎样的处理。但generator的缺点也很明显，那就是很原生（自己的理解），对于函数里的执行时机需要完全自己去写逻辑控制，需要自己判断什么时候异步操作执行完成，然后还要自己去调用下一步的操作，总的来说就是不够智能。 co模块co模块就是一个智能的generator自动执行器,只需要把generator函数传入co函数，函数体内的语句就能自动执行，完全不用考虑执行时机的问题。co函数返回一个Promise对象，因此还可以用then方法来添加回调函数.使用起来很简单:12345678910var gen = function* () &#123; var f1 = yield readFile('/etc/fstab'); var f2 = yield readFile('/etc/shells'); console.log(f1.toString()); console.log(f2.toString());&#125;;var co = require('co');co(gen).then(function ()&#123; console.log('Generator 函数执行完成');&#125;); 处理并发的异步操作并发的异步就是说几个异步同时开始进行，而不是排队一个一个进行。写法如下：12345678910111213141516co(function* () &#123; var res = yield [ Promise.resolve(1), Promise.resolve(2) ]; console.log(res);&#125;).catch(onerror);// 对象的写法co(function* () &#123; var res = yield &#123; 1: Promise.resolve(1), 2: Promise.resolve(2), &#125;; console.log(res);&#125;).catch(onerror); 终极异步方案（或许）–async函数引用阮老师原文对async的描述： async 函数是什么？一句话，它就是 Generator 函数的语法糖。 内置执行器Generator 函数的执行必须靠执行器，所以才有了co模块，而async函数自带执行器。也就是说，async函数的执行，与普通函数一模一样，只要一行。 更好的语义async和await，比起星号和yield，语义更清楚了。async表示函数里有异步操作，await表示紧跟在后面的表达式需要等待结果。 更广的适用性co模块约定，yield命令后面只能是 Thunk 函数或 Promise 对象，而async函数的await命令后面，可以是Promise 对象和原始类型的值（数值、字符串和布尔值，但这时等同于同步操作）。 返回值是Promiseasync函数的返回值是 Promise 对象，这比 Generator 函数的返回值是 Iterator 对象方便多了。你可以用then方法指定下一步的操作。 async函数的使用async函数的使用也非常简单:123456789101112async function timeout(ms) &#123; await new Promise((resolve) =&gt; &#123; setTimeout(resolve, ms); &#125;);&#125;async function asyncPrint(value, ms) &#123; await timeout(ms); console.log(value);&#125;asyncPrint('hello world', 50); 最后，贴出使用async函数的注意点: 正常情况下，await命令后面是一个 Promise对象。如果不是，会被转成一个立即resolve的 Promise 对象。所以运行结果可能是rejected，最好把await命令放在try…catch代码块中。 多个await命令后面的异步操作，如果不存在继发关系，最好让它们同时触发。有以下两种写法: 1234567 // 写法一,比较好理解let [foo, bar] = await Promise.all([getFoo(), getBar()]);// 写法二，结构更加清晰let fooPromise = getFoo();let barPromise = getBar();let foo = await fooPromise;let bar = await barPromise; await命令只能用在async函数之中，如果用在普通函数，就会报错 关于更多关于异步编程的一些实现原理和细节的东西，阮一峰老师的es6入门教程和博客里写得非常详尽，就不再班门弄斧了。最后，再次感谢阮老师的教程，让我受益匪浅。","pubDate":"Thu, 17 May 2018 11:25:02 GMT","guid":"https://leaf930814.github.io/notes/2018/05/17/JS异步编程的前世今生/","category":"总结"}]}